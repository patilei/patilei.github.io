<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MYSQL基础语法</title>
      <link href="/2023/09/10/MYSQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/09/10/MYSQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是数据库？什么是数据管理系统-什么是SQL？它们之间的关系是什么？"><a href="#什么是数据库？什么是数据管理系统-什么是SQL？它们之间的关系是什么？" class="headerlink" title="什么是数据库？什么是数据管理系统?什么是SQL？它们之间的关系是什么？"></a>什么是数据库？什么是数据管理系统?什么是SQL？它们之间的关系是什么？</h4><p>数据库：DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p><p>数据库管理系统：DataBaseManagement，简称DBMS。专门用来管理数据中的数据，数据库管理系统可以对数据库中的数据进行增删改查。如MySql，Oracle，MS，SqlServer，DB2，sybase等…</p><p>SQL：结构化查询语句，程序员通过编写SQL语句，DBMS负责执行SQL语句，最终来完成数据库中的数据的增删改查操作.SQL是一套标准，可以应用到各种数据库管理系统中。</p><p>三者之间的关系：数据库管理系统使用SQL语句来对数据库执行增删改查操作。</p><p>DBMS—&gt;SQL—&gt;DB</p><h4 id="命令行开启Mysql服务和关闭服务"><a href="#命令行开启Mysql服务和关闭服务" class="headerlink" title="命令行开启Mysql服务和关闭服务"></a>命令行开启Mysql服务和关闭服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL 停止 net stop MySQL 停止</span><br></pre></td></tr></table></figure><h4 id="mysql常用命令行"><a href="#mysql常用命令行" class="headerlink" title="mysql常用命令行"></a>mysql常用命令行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">登录mysql -u用户名 -p密码</span><br><span class="line">退出mysql：exit</span><br><span class="line">查看有哪些数据库：show databases; 以英文分号结尾</span><br><span class="line">选择数据库：use test;</span><br><span class="line">创建数据库：create datebase 数据库名;</span><br><span class="line">查看数据库表:show tables;</span><br><span class="line">导入数据：source 路径</span><br><span class="line">查看表结构 describe缩写 desc 表名</span><br><span class="line">查看数据库版本号：select verson();</span><br><span class="line">查看当前数据库：select database();</span><br><span class="line">\c 终止一条sql语句的输入</span><br><span class="line">注：不区分大小，不见分号不执行</span><br></pre></td></tr></table></figure><h4 id="数据库中最基本的表单元是表：table，任何一张表都有行和列，行（row）数据记录、列（column）称为字段"><a href="#数据库中最基本的表单元是表：table，任何一张表都有行和列，行（row）数据记录、列（column）称为字段" class="headerlink" title="数据库中最基本的表单元是表：table，任何一张表都有行和列，行（row）数据记录、列（column）称为字段"></a>数据库中最基本的表单元是表：table，任何一张表都有行和列，行（row）数据记录、列（column）称为字段</h4><h4 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h4><p>DQL：数据查询语句 select </p><p>DML:数据操作语言 insert增，delete删，update改</p><p>DDL:数据定义语言，带create新建表、drop删除、alter修改</p><p>TCL：事物控制，事物提交 commit，事物回滚：rollback；</p><p>DCL：数据控制语言，授权grant、撤销权限revoke</p><h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><p>查询一个字段：select 和from是关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段名 <span class="keyword">from</span> 表名;   </span><br></pre></td></tr></table></figure><p>查询多个字段： 查询字段之间使用,来隔开</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>   cloumn1，cloumn2 <span class="keyword">from</span> 表名;  </span><br></pre></td></tr></table></figure><p>查询所有字段：第2种方式可读性较差，效率低，不可取，*在运行的时候也会转换为字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">select</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span> <span class="keyword">from</span> 表名</span><br><span class="line"><span class="number">2.</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><p>使用as关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">as</span> 别名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>不适用as关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 别名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>别名关键字中间有空格怎么操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.select 字段名 &#x27;别 名&#x27; from 表名</span><br><span class="line">2.select 字段名 &quot;别 名&quot; from 表名</span><br><span class="line">注：在数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle中不可以使用，在mysql中可以使用。</span><br></pre></td></tr></table></figure><h4 id="条件查询一"><a href="#条件查询一" class="headerlink" title="条件查询一"></a>条件查询一</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法格式：<span class="keyword">select</span> </span><br><span class="line">              字段名<span class="number">1</span>，字段名<span class="number">2.</span>...</span><br><span class="line">              <span class="keyword">from</span></span><br><span class="line">              表名</span><br><span class="line">              <span class="keyword">where</span></span><br><span class="line">              条件;</span><br><span class="line">              <span class="operator">=</span> 等于</span><br><span class="line">              <span class="operator">&gt;</span>大于 </span><br><span class="line">              <span class="operator">&lt;</span>小于</span><br><span class="line">              <span class="operator">&lt;=</span>小于等于 </span><br><span class="line">              <span class="operator">=</span>大于等于 </span><br><span class="line">              <span class="operator">!=</span>不等于</span><br><span class="line">              <span class="keyword">and</span>并且</span><br><span class="line">              <span class="keyword">between</span> ... <span class="keyword">and</span> ... 必须遵循左小右大，闭区间</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段名<span class="number">1</span>，字段名<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="operator">=</span>xxx；</span><br><span class="line"><span class="keyword">select</span>  字段名<span class="number">1</span>，字段名<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="operator">&gt;</span>xxx <span class="keyword">and</span> 字段名<span class="number">1</span><span class="operator">&lt;</span>xxxx；</span><br><span class="line"><span class="keyword">select</span>  字段名<span class="number">1</span>，字段名<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="keyword">between</span> xxx <span class="keyword">and</span> xxx;</span><br></pre></td></tr></table></figure><h4 id="条件查询二"><a href="#条件查询二" class="headerlink" title="条件查询二"></a>条件查询二</h4><h5 id="条件为空-is-null"><a href="#条件为空-is-null" class="headerlink" title="条件为空 is null"></a>条件为空 is null</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名 where 字段名 is null;</span><br></pre></td></tr></table></figure><h5 id="条件不为空-is-not-null"><a href="#条件不为空-is-not-null" class="headerlink" title="条件不为空 is not null"></a>条件不为空 is not null</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名 where 字段名 is not null;</span><br></pre></td></tr></table></figure><h5 id="or或者"><a href="#or或者" class="headerlink" title="or或者"></a>or或者</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span>  表名   <span class="keyword">where</span> 字段名<span class="number">1</span><span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> <span class="keyword">or</span> 字段名<span class="number">2</span><span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">and</span>和<span class="keyword">or</span>同时出现有优先级问题吗?</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">1</span> <span class="keyword">or</span> 条件<span class="number">2</span></span><br><span class="line">注：<span class="keyword">and</span>和<span class="keyword">or</span>如果同时出现，<span class="keyword">and</span>的优先级要高于<span class="keyword">or</span>，如果想让<span class="keyword">or</span>先执行需要加小括号，不确定优先级可以直接加小括号。</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="keyword">and</span> (条件<span class="number">1</span> <span class="keyword">or</span> 条件<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="in包含指的是具体的数值-not不包含这些具体的数值"><a href="#in包含指的是具体的数值-not不包含这些具体的数值" class="headerlink" title="in包含指的是具体的数值,not不包含这些具体的数值"></a>in包含指的是具体的数值,not不包含这些具体的数值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>包含：<span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> (xxx,xxx);</span><br><span class="line"><span class="number">2.</span>不包含：<span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">not</span> <span class="keyword">in</span> (xxx,xxx);</span><br></pre></td></tr></table></figure><h5 id="like模糊查询"><a href="#like模糊查询" class="headerlink" title="like模糊查询"></a>like模糊查询</h5><p>支持%和下划线匹配，%任意匹配多个字符，下划线表示任意一个字符，都是特殊符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名  where 字段名  like &#x27;%o&#x27;;</span><br><span class="line">select 字段名 from 表名  where 字段名  like &#x27;_o&#x27;;//代表第二个字符是o</span><br><span class="line">如果查询的结果有_,因为_具有特殊意义代表任意一个字符所以在查询的时候需要转义，例：\_</span><br></pre></td></tr></table></figure><h5 id="排序ORDER-BY"><a href="#排序ORDER-BY" class="headerlink" title="排序ORDER BY"></a>排序ORDER BY</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.指定升序：SELECT 字段名1 FROM 表名 ORDER BY 字段名1 asc；</span><br><span class="line">2.指定降序：SELECT 字段名1 FROM 表名 ORDER BY 字段名1 desc；</span><br></pre></td></tr></table></figure><p>多条件升序、降序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名<span class="number">1</span> <span class="keyword">asc</span>，字段名<span class="number">2</span> <span class="keyword">asc</span>；<span class="operator">/</span><span class="operator">/</span>字段<span class="number">1</span>起主导作用，如果字段<span class="number">1</span>相同就会使用字段名<span class="number">2</span>来进行升降序。</span><br></pre></td></tr></table></figure><p>根据字段位置进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名1  FROM 表名 ORDER BY 2  该方法作为了解，在开发中不适用，如果列发生变化，该sql就废了</span><br></pre></td></tr></table></figure><p>注：在综合案例中，排序总是在最后执行。</p><h4 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h4><p>数据处理函数又分为单行处理函数和多行处理函数。</p><p>单行处理函数：一个输入对应一个输出。</p><p>多行处理函数：多个输入，对应一个输出。</p><p>单行常见的函数有： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lower 转换小写</span><br><span class="line"></span><br><span class="line">upper  转换大写</span><br><span class="line"></span><br><span class="line">substr 取子串 (substr(被截取的字符串，起始下标，截取的长度))</span><br><span class="line">注：起始下标从1开始，没有0</span><br><span class="line">length取长度</span><br><span class="line"></span><br><span class="line">trim去空格</span><br><span class="line"></span><br><span class="line">str_to_data 将字符串转换成日期</span><br><span class="line"></span><br><span class="line">data_format 格式化日期</span><br><span class="line"></span><br><span class="line">format 设置千分位</span><br><span class="line"></span><br><span class="line">rand()生成随机数</span><br><span class="line"></span><br><span class="line">ifnull 可以将null转换成一个具体值</span><br><span class="line">null只要参数运算，最终结果一定是null，为了避免情况，需要使用ifnull函数</span><br><span class="line"></span><br><span class="line">concat字符串 拼接</span><br><span class="line"></span><br><span class="line">case..when..then..when..then..else..end</span><br><span class="line"></span><br><span class="line">case 字段 when当什么时候，then做什么....when当什么时候 ... 其他...</span><br></pre></td></tr></table></figure><h4 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h4><p>多行处理函数，输入多行，输出一行。</p><p>​        count计数</p><p>​        count(具体字段)：标识统计该字段下所有不为NULL的元素的总数</p><p>​        count(*)：统计表中的总行数，只要有一行数据就count++，因为每一行记录不可能都为NULL，一行数据中只要有一列不为NULL，则这行数据就是有效的。</p><p>​        sum 求和</p><p>​        avg平均值</p><p>​        max最大值</p><p>​        min最小值</p><p>​    注：1.分组函数使用的时候，必须先进行分组才可以使用，如果没有分组，整张表是一组数据。</p><p>​            2.分组函数自动忽略null，不需要提前对null值进行处理。</p><p>​            3.分组函数不能只能使用在where子句中</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>什么是分组查询？</p><p>需要先对一组数据进行分组，然后再对这组数据进行操作。</p><p>如：计算每个部门的工资和？计算每个岗位的平均薪资？找个每个工资岗位的最高薪资?</p><p>关键字的执行顺序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">...</span><br><span class="line">注：以上关键字的顺序不能颠倒。</span><br><span class="line">执行顺序：</span><br><span class="line"><span class="number">1.</span><span class="keyword">from</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">where</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">select</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">如果在一条<span class="keyword">select</span>语句中，如果有<span class="keyword">group</span> <span class="keyword">by</span>语句的话，<span class="keyword">select</span>后面只能跟：参与分组的字段名，以及分组函数，其他一律不能跟。</span><br><span class="line"></span><br><span class="line"><span class="keyword">having</span>:对分完组之后的数组进一步过滤，<span class="keyword">having</span>不能单独使用，<span class="keyword">having</span>不能代替<span class="keyword">where</span>，<span class="keyword">having</span>必须联合<span class="keyword">group</span> <span class="keyword">by</span>联合使用</span><br><span class="line">优化策略：<span class="keyword">where</span>和<span class="keyword">having</span>优先选择<span class="keyword">where</span>，<span class="keyword">where</span>完不成不了，选择<span class="keyword">having</span></span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">单表查询的执行顺序：执行顺序不能颠倒</span><br><span class="line"><span class="number">1.</span><span class="keyword">from</span> 从某张表中查出数据</span><br><span class="line"><span class="number">2.</span><span class="keyword">where</span>经过<span class="keyword">where</span>条件筛选数据</span><br><span class="line"><span class="number">3.</span><span class="keyword">group</span> <span class="keyword">by</span> 这这些数据进行分组</span><br><span class="line"><span class="number">4.</span><span class="keyword">having</span> 分组之后可以继续使用<span class="keyword">having</span>进行过滤</span><br><span class="line"><span class="number">5.</span><span class="keyword">select</span> 查询出来</span><br><span class="line"><span class="number">6.</span><span class="keyword">order</span> <span class="keyword">by</span> 排序输出</span><br></pre></td></tr></table></figure><p>13.去除重复记录（去重）distinct</p><p>注：原数据库的数据不会被改动，只是查询的结果去重。    </p><p>distinct 字段只能出现在所有字段的前方，可以放在分组函数里边执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  distinct 字段名 from emp；</span><br></pre></td></tr></table></figure><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h5 id="根据语法的年代分类："><a href="#根据语法的年代分类：" class="headerlink" title="根据语法的年代分类："></a>根据语法的年代分类：</h5><p>SQL92：1992年出现的语法</p><p>SQL99：1999年出现的语法</p><p>表的连接方式方式分类：</p><p>​                                        内连接</p><p>​                                                    等值连接                                                    </p><p>​                                                    非等值连接</p><p>​                                                    自连接</p><p>​                                        外连接</p><p>​                                                    左外连接</p><p>​                                                    右外连接</p><p>​                                        全连接（使用较少）</p><p>当两张表进行查询时，没有任何条件的限制，最终查询结果条数，是两张表的乘积，这种现象称为笛卡尔现象，这是一个数学现象。</p><p>怎么避免笛卡尔现象，在连接的时候加条件，满足这个条件的数据被筛选出来。</p><p>select emp.ename from emp,dept where emp.deptno = dept .deptno;  //SQL92语法效率较低</p><p>注：避免笛卡尔现象，表的连接次数越多效率越低，避免表的连接次数。</p><h5 id="内连接之等值连接"><a href="#内连接之等值连接" class="headerlink" title="内连接之等值连接"></a>内连接之等值连接</h5><p>内连接语法格式：select 字段名 from 表1 inner join 表 2 on 条件</p><p>此处的inner 可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.ename,d.deptno from emp e inner join dept d on e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><h5 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">注：on后边的条件不是一个等量关系。 </span><br></pre></td></tr></table></figure><h5 id="内连接之自连接"><a href="#内连接之自连接" class="headerlink" title="内连接之自连接"></a>内连接之自连接</h5><p>自连接的技巧：一张表看成两张表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.ename,b.ename,b.empno from emp a join emp b on a.mgr = b.empno;</span><br></pre></td></tr></table></figure><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>left outer join….on …. //outer 可以省略加上可读性较强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.ename,b.ename from emp a left outer join emp b on a.mgr =b.empno;</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>right outer join….on…. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.ename,b.ename from emp a right outer join emp b on a.mgr =b.empno;</span><br></pre></td></tr></table></figure><p>注：主表代表查询该主表的全部内容，</p><p>14.三张表、四张表的连接</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">     ....</span><br><span class="line">     from</span><br><span class="line">     a</span><br><span class="line">     join</span><br><span class="line">     b</span><br><span class="line">     on</span><br><span class="line">       a表与b表的连接条件</span><br><span class="line">     join </span><br><span class="line">     c</span><br><span class="line">     on</span><br><span class="line">       a表与c表的连接条件</span><br><span class="line">     left join </span><br><span class="line">     d</span><br><span class="line">     on</span><br><span class="line">       a表与d表的连接条件</span><br><span class="line"></span><br><span class="line">注：一条sql中内连接和外连接都可以混合出现。 </span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p> 什么是子查询，select语句中嵌套select语句，被嵌套的select的语句被称为子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select</span><br><span class="line">（select语句）</span><br><span class="line">   from</span><br><span class="line">   （select语句）</span><br><span class="line">   where </span><br><span class="line">     （select语句）</span><br><span class="line">     </span><br><span class="line">where子句中的子查询：select ename,sal from emp where sal &gt;(select min(sal) from emp);</span><br><span class="line"></span><br><span class="line">from子句中的子查询：</span><br><span class="line">from后面的子查询可以将子查询结果当做一张临时表，属于一种编程思想。</span><br><span class="line">select t.job,s.grade,t.avg  from (select job,avg(sal) as avg from emp group by job) t join salgrade s on t.avg between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">select子查询</span><br><span class="line">对于select子查询一次只能返回一条结果，如果返回多条就报错。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="union合并查询结果集"><a href="#union合并查询结果集" class="headerlink" title="union合并查询结果集"></a>union合并查询结果集</h4><p>union的效率要高一些，对于表连接来说，每连接一次新表，每一次匹配的次数都是成倍的翻。但是union可以减少匹配的次数，在减少匹配次数的情况下，可以完成两个结果集的拼接。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit是将查询结果的一部分取出来，一般使用在分页查询当中。</p><p>完整用法：limit  startIndex，length    startIndex是起始下标，length是长度</p><p>缺省用法：limit 5；取前5代表的是长度</p><p>注:limit是在order by 之后执行的。</p><p>分页公式：limit (pageNo-1)*pageSize,pageSize</p><h4 id="表的创建（建表）"><a href="#表的创建（建表）" class="headerlink" title="表的创建（建表）"></a>表的创建（建表）</h4><h5 id="建表的语法格式"><a href="#建表的语法格式" class="headerlink" title="建表的语法格式"></a>建表的语法格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table 表名（</span><br><span class="line"></span><br><span class="line">字段名1 数据类型，</span><br><span class="line"></span><br><span class="line">字段名2 数据类型，</span><br><span class="line"></span><br><span class="line">字段名3 数据类型</span><br><span class="line"></span><br><span class="line">）;</span><br><span class="line">类名：建议以t_或tbl_开始，可读性较强</span><br><span class="line">字段名：见名知意</span><br><span class="line">表名和字段名都属于标识符</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="关于数据库的数据类型"><a href="#关于数据库的数据类型" class="headerlink" title="关于数据库的数据类型"></a>关于数据库的数据类型</h5><p>varchar（255）：可变长度的字符串，比较智能节省空间，会根据实际的数据长度动态分配空间。</p><p>char（255）：定长字符串，不管实际的数据长度是多少，分配固定长度的空间是存储数据。使用不恰当的时候可能会导致空间的浪费。</p><p>注：如果字符串是固定的位数可以选择char，如果不固定选择varchar，varchar是动态扩容的，效率低，char是固定的容量，缺点是会导致空间的浪费。</p><p>int（11）：等同于java中的int</p><p>bigint：等同于java中的lang</p><p>float：单精度浮点型数据</p><p>double :双精度浮点型</p><p>data：短日期类型</p><p>datatime：长日期类型</p><p>clob：字符大对象，最多可以存储4个g的字符串，超过255个字符都要选用clob大对象。</p><p>blob：二进制大对象，专门用来存储图片，视频等流媒体数据，插入图片，视频等类型的数据时候需要使用IO流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除表的sql</span><br><span class="line">drop table if exists t_student2;</span><br><span class="line"></span><br><span class="line">drop  table  表名</span><br></pre></td></tr></table></figure><h4 id="插入数据-insert"><a href="#插入数据-insert" class="headerlink" title="插入数据   insert"></a>插入数据   insert</h4><p>语法格式：insert into 表名（字段名1，字段名2，字段名3 …）values （值1，值2，值3）;</p><p>字段名要和值一一对应，数量要对应，数据类型要对应</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL高级进阶</title>
      <link href="/2023/09/10/MYSQL%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/09/10/MYSQL%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库三范式："><a href="#数据库三范式：" class="headerlink" title="数据库三范式："></a>数据库三范式：</h3><p>第一范式：每张表必须有主键，并且每一个字段是原子性不可再分。</p><p>第二范式：在第一范式的基础上，要求所有非主键字段完全依赖主键，不产生部分依赖，保证一张表只描述一件事情。</p><p>第三范式：在第二范式的基础上，要求所有非主键字段之间依赖主键，不要产生传递依赖，表中字段和主键直接对应不依靠其他中间字段。</p><p>按照范式设计数据库可以避免表中数据的冗余，空间的浪费，在实际中，一般互联网公司都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p><p>一对一：一张表中一条数据只能对应另一张表的一条的数据，给其中的一张表+外键+唯一约束unique，其实上语法跟多对多没有太大区别。</p><p>一对多：两张表，多的表多外键</p><p>多对多：三张表，关系表加外键，额外创建关系表存放两张表的id键值</p><h3 id="Mysql-有关的权限表？"><a href="#Mysql-有关的权限表？" class="headerlink" title="Mysql 有关的权限表？"></a>Mysql 有关的权限表？</h3><p>user权限表:记录服务器的用户信息</p><p>db权限表：记录账号的操作权限</p><p>table_priv权限表：数据库表级的操作权限</p><p>columns_priv权限表：数据列级的操作权限</p><p>host权限表：配合db表给指定主机做更细致的控制</p><h3 id="binlog有几种录入方式？分别有什么区别？"><a href="#binlog有几种录入方式？分别有什么区别？" class="headerlink" title="binlog有几种录入方式？分别有什么区别？"></a>binlog有几种录入方式？分别有什么区别？</h3><p>三种</p><p>statement:每一条修改数据的sql都会被记录在binlog日志中</p><p>row：记录每行的改动</p><p>mixed：折中的方案。普通操作会使用statement、当无法使用statement的时候使用row。</p><h3 id="mysql的数据类型有哪些？"><a href="#mysql的数据类型有哪些？" class="headerlink" title="mysql的数据类型有哪些？"></a>mysql的数据类型有哪些？</h3><p>整数类型：tinyInt 8位、smallint 16位、medium int 24位、int 32位</p><p>小数类型 ：float单精度 double双精度 decimal(m,d) 严格的定点数 10位进制</p><p>日期类型：year、time、date、datetime、timestamp（英 /ˈtaɪmstæmp/）</p><p>文本、二进制 类型 ：CHAR、VARCHAR、TINYBLOB、BLOB、TEXT等</p><h3 id="Mysql的基础架构"><a href="#Mysql的基础架构" class="headerlink" title="Mysql的基础架构"></a>Mysql的基础架构</h3><p>1.客户端层：用户访问Mysql的接口。在客户端，用户输入SQL语句，实现对数据库的访问、操作和控制</p><p>2.Server层：包括连接器、查询缓存、分析器、优化器、执行器、以及所有的内置函数（如日期、时间、数学和加密函数），所有的跨存储引擎功能都在这一层实现，比如存储过程、触发器、视图等</p><p>连接器:负责跟客户端建立连接、获取权限、维持和管理连接。</p><p>查询缓存：用来缓存所执行的SELECT语句以及该语句的结果集。</p><p>分析器：</p><p>3.存储引擎层：负责数据的存储和提取。模式：插件式，支持InnDB、MyISAM、Memory等多个存储引擎，常用默认存储引擎InnoDB，从5.5.5版本成为了默认引擎</p><h3 id="创建索引的优点和缺点？"><a href="#创建索引的优点和缺点？" class="headerlink" title="创建索引的优点和缺点？"></a>创建索引的优点和缺点？</h3><p>优点：1.类似于图书馆建立书的目录，提高数据检索的效率，降低数据库的IO成本。</p><p>​            2.通过创建唯一索引，可以保证数据的唯一性。</p><p>​            3.在实现数据的完整数方面，可以加速表和表之间的连接，联合父表和子表可以提高查询效率。</p><p>​            4.在使用分组和排序进行查询数据时，可以减少查询分组和排序的时间，降低cpu的消耗</p><p>缺点：1.创建索引和维护索引需要耗费时间，随着数据数量的增加，所耗费的时间也会增加</p><p>​            2.索引需要占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占用一定的物理空间，</p><p>​            3.虽然索引提高了查询速度，确会降低表的更新速度，当对表进行增删改查时，索引也需要动态的维护，降低了维护的速度。</p><h3 id="mysql的引擎"><a href="#mysql的引擎" class="headerlink" title="mysql的引擎?"></a>mysql的引擎?</h3><p>mysql中的数据，索引以及对象使通过引擎进行存储的。</p><p>常用的引擎有MyIASM、Innobd</p><p>Innodb引擎:提供了对数据库ACID的事物支持，并且还提供了行锁级和外键的约束。</p><p>MyIASM：不提供事物的支持，不支持行级锁和外键。</p><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</p><h3 id="什么是索引？（主键索引使用二分查找，每页数据有目录项（取最小值为目录项），如果7-8-9取8页的话，选用二分查找可以直接定位到7和9中间的是8-这样效率就可以更快）"><a href="#什么是索引？（主键索引使用二分查找，每页数据有目录项（取最小值为目录项），如果7-8-9取8页的话，选用二分查找可以直接定位到7和9中间的是8-这样效率就可以更快）" class="headerlink" title="什么是索引？（主键索引使用二分查找，每页数据有目录项（取最小值为目录项），如果7,8,9取8页的话，选用二分查找可以直接定位到7和9中间的是8,这样效率就可以更快）"></a>什么是索引？（主键索引使用二分查找，每页数据有目录项（取最小值为目录项），如果7,8,9取8页的话，选用二分查找可以直接定位到7和9中间的是8,这样效率就可以更快）</h3><h3 id="为什么b-树最多不超过4层？"><a href="#为什么b-树最多不超过4层？" class="headerlink" title="为什么b+树最多不超过4层？"></a>为什么b+树最多不超过4层？</h3><p>层数越低，IO的次数越少，1层 100条记录，2层 10万条数据，3层一亿条数据，4层1000亿条数据，</p><p>索引是一种数据结构，也是表空间组成的重要部分，包含着每条记录的引用地址。</p><p>主要是用来协助快速查询，更新表中数据。通常最常见的数据结构有b树，b+树。</p><p>注：1.使用order by排序的时候要将该字段建立成索引，如果不建立成索引，就会使用一个外部排序，外部排序就是将数据分批从磁盘读取到内存中使用内部排序，最后进行合并排序。</p><p>2.join</p><p>join on涉及的字段建立索引，能够提高效率。</p><h3 id="索引的类型？"><a href="#索引的类型？" class="headerlink" title="索引的类型？"></a>索引的类型？</h3><p>主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。</p><p>唯一索引：数据列不允许重复，允许为null值，一个允许多个列创建唯一索引 。</p><p>可以通过ALTERTABLEtable_nameADDUNIQUE(column); 创建唯一索引 可以通过ALTERTABLEtable_nameADDUNIQUE(column1,column2); 创建唯一组合索引</p><p>普通索引:基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p>全文索引：是目前搜索引擎使用的一种关键技术。</p><h3 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h3><p>存储引擎决定着索引的数据结构，常用的索引有b+树索引、hash索引，经常使用的是InnoDb引擎默认是索引实现是b+树索引。</p><p>对于hash索引来说，底层的数据结构就是hash表，因此在绝大多数需求查询为单条的时候可以选择hash索引，查询性能快，其他的部分场景使用bTree索引 。</p><p>常用的索引有b树（b树是由b+树实现的），hash索引。</p><h3 id="聚簇索引、二级索引、联合索引？"><a href="#聚簇索引、二级索引、联合索引？" class="headerlink" title="聚簇索引、二级索引、联合索引？"></a>聚簇索引、二级索引、联合索引？</h3><p>聚簇索引就是以主键底层为b+树实现的就是聚簇索引，非聚簇索引就是二级索引和辅助索引。</p><p>聚簇索引就是一种存储结构，数据表中的每条数据都存储在叶子节点上，聚簇表示：数据行和相邻的的键值聚簇存储在一起。</p><p>二级索引：查询第一棵二叉树，第一棵树中国存放非聚簇索引字段和主键聚簇索引字段进行排序，先用二分查找找到非聚簇字段所在的位置，然后根据对应的聚簇索引进行第二棵树查询，就是回表。</p><p>连表索引：就是将所有的非聚簇索引字段放在一起，然后排序之后，根据主键进行回表查询。</p><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><p>索引是一种数据结构，可以帮助快速查找数据，可以把他理解为目录。</p><h3 id="都可以加索引吗，这样是不是会很快？"><a href="#都可以加索引吗，这样是不是会很快？" class="headerlink" title="都可以加索引吗，这样是不是会很快？"></a>都可以加索引吗，这样是不是会很快？</h3><p>索引也不可以盲目的加，索然他使用优化隐藏器提高性能，但是也会占用物理空间。从而降低增删改的速度，因为操作数据的同时也要维护数据的索引文件。</p><p>你知道索引的数据结构是什么吗?用啥实现的？</p><p>常用的索引文件有B+树，hash，我们常用的Innodb引擎是B+树实现的</p><h3 id="为啥不用hash做为索引？"><a href="#为啥不用hash做为索引？" class="headerlink" title="为啥不用hash做为索引？"></a>为啥不用hash做为索引？</h3><p>hash的底层是hash表实现，等值查询可以快速的定位，一般情况效率很高，不稳定，无法用于分组，排序，模糊查询。</p><h3 id="为何使用B-树，不适用B树？"><a href="#为何使用B-树，不适用B树？" class="headerlink" title="为何使用B+树，不适用B树？"></a>为何使用B+树，不适用B树？</h3><p>B+树在叶子结点储存数据，其余的结点是用来存储索引的，而结点就是一个磁盘的内存页。B树的每个索引结点都会有数据域，这就决定了B+树更适合来存储数据，B类树的特点就是节点数目多，层数很少，主要目的还是为了减少IO的次数，B+能够很快的查找索引位置，然后进行读取数据。</p><h3 id="索引类型有哪些？"><a href="#索引类型有哪些？" class="headerlink" title="索引类型有哪些？"></a>索引类型有哪些？</h3><p>普通索引</p><p>主键索引</p><p>唯一索引</p><p>全文索引</p><h3 id="索引覆盖是什么？"><a href="#索引覆盖是什么？" class="headerlink" title="索引覆盖是什么？"></a>索引覆盖是什么？</h3><p>就是索引字段覆盖了查询语句涉及的字段，直接通过索引文件就可以返回所需要的数据，不需要回表操作。</p><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>通过索引去找主键，然后再根据主键ID去主键索引查，InnoDB使用的是聚簇索引。</p><h3 id="普通索引和唯一索引，主键索引的使用场景？"><a href="#普通索引和唯一索引，主键索引的使用场景？" class="headerlink" title="普通索引和唯一索引，主键索引的使用场景？"></a>普通索引和唯一索引，主键索引的使用场景？</h3><p>普通索引：可以重复</p><p>唯一索引：只能是唯一一个，可以为空</p><p>主键索引：不能为空，因为他要作为聚簇索引排序，所以使用主键不能为null。</p><p>首先我们知道查询会以页为单位将数据加载到内存中，不需要逐条进行读取，唯一索引就是查到数据就会返回结果，普通索引就是查到第一条记录，往后遍历直到不满足条件，都在内存中。不需要磁盘读取，带来开销几乎忽略不计。</p><p>更新哪个更好：唯一索引更新的时候要检查唯一性，所以先要将数据页加载到内存中才能判断，此时操作内存，不需要操作chang buffer.</p><p>普通索引若数据在内存中就直接在内存中更新，否则会将更新操作先记录到changge buffer里相关更新操作后将数据返回，在写多读少的情况下就减少了IO的操作，就可以不用change buffer，不但没提高多少效率还造成维护change buffer额外的消耗</p><h3 id="Innodb的四大特性"><a href="#Innodb的四大特性" class="headerlink" title="Innodb的四大特性"></a>Innodb的四大特性</h3><p>插入缓冲：为了减少IO的访问次数</p><p>二次写：弥补磁盘的原子性</p><p>自适应hash：Innodb会监控各索引页的查询，如果观察到建立哈希索引能够对性能提升，就会建立哈希索引。</p><p>预读：线性预读和随机预读</p><h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h3><p>就是左优先，where子句中使用最频繁的放到最左边。</p><h3 id="什么是数据库事物？"><a href="#什么是数据库事物？" class="headerlink" title="什么是数据库事物？"></a>什么是数据库事物？</h3><p>数据库的事物是并发的最基础单位之一，都么都执行，要么都不执行。</p><p>事物的四大特性？</p><p>原子性：要么全部执行，要么全部不执行</p><p>一致性：操作之前的总数和操作之后的总数，数量不变        </p><p>隔离性：两个人同时去操作一件事，不会影响</p><p>持久性：提交数据，数据库表中的数据发生变化</p><h3 id="数据库隔离级别？"><a href="#数据库隔离级别？" class="headerlink" title="数据库隔离级别？"></a>数据库隔离级别？</h3><p>脏读：一个未提交事务读取到另一个未提交事务的数据</p><p>不可重复读： 一个未提交事务读取到另一提交事务修改数据</p><p><strong>幻读</strong>：一个未提交事务读取到另一提交事务添加的数据</p><p>什么是死锁，怎么解决？</p><p>死锁就是两个事物或多个事物，请求到同一资源并且进行锁定，进入恶性循环。</p><h3 id="MYSQL存储过程？"><a href="#MYSQL存储过程？" class="headerlink" title="MYSQL存储过程？"></a>MYSQL存储过程？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="18-SQL语句主要分为哪几类"><a href="#18-SQL语句主要分为哪几类" class="headerlink" title="18.SQL语句主要分为哪几类"></a>18.SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="20-如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#20-如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="20.如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>20.如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p><h3 id="21-大表数据查询，怎么优化"><a href="#21-大表数据查询，怎么优化" class="headerlink" title="21.大表数据查询，怎么优化"></a>21.大表数据查询，怎么优化</h3><p>\1.   优化shema、sql语句+索引；</p><p>\2.   第二加缓存，memcached, redis；</p><p>\3.   主从复制，读写分离；</p><p>\4.   垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p><p>\5.   水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="22-为什么要优化"><a href="#22-为什么要优化" class="headerlink" title="22.为什么要优化"></a>22.为什么要优化</h3><p>·    系统的吞吐量瓶颈往往出现在数据库的访问速度上</p><p>·    随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</p><p>·    数据是存放在磁盘上的，读写速度无法和内存相比</p><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h3 id="23-数据库结构优化"><a href="#23-数据库结构优化" class="headerlink" title="23.数据库结构优化"></a>23.数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p><strong>将字段很多的表分解成多个表</strong></p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p><strong>增加中间表</strong></p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p><strong>增加冗余字段</strong></p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意：</strong></p><p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p><h3 id="24-MySQL的复制原理以及流程"><a href="#24-MySQL的复制原理以及流程" class="headerlink" title="24.MySQL的复制原理以及流程"></a>24.MySQL的复制原理以及流程</h3><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p><strong>主从复制的作用</strong></p><p>\1.   主数据库出现问题，可以切换到从数据库。</p><p>\2.   可以进行数据库层面的读写分离。</p><p>\3.   可以在从数据库上进行日常备份。</p><p><strong>MySQL****主从复制解决的问题</strong></p><p>·    数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</p><p>·    负载均衡：降低单个服务器的压力</p><p>·    高可用和故障切换：帮助应用程序避免单点失败</p><p>·    升级测试：可以用更高版本的MySQL作为从库</p><p><strong>MySQL****主从复制工作原理</strong></p><p>·    在主库上把数据更高记录到二进制日志</p><p>·    从库将主库的日志复制到自己的中继日志</p><p>·    从库读取中继日志的事件，将其重放到从库数据中</p><p><strong>基本原理流程，3个线程以及之间的关联</strong></p><p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p><p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p><h3 id="25-读写分离有哪些解决方案？"><a href="#25-读写分离有哪些解决方案？" class="headerlink" title="25.读写分离有哪些解决方案？"></a>25.读写分离有哪些解决方案？</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。 </p><h1 id="MySql高频面试题梳理"><a href="#MySql高频面试题梳理" class="headerlink" title="MySql高频面试题梳理"></a>MySql高频面试题梳理</h1><h2 id="基础知识题型"><a href="#基础知识题型" class="headerlink" title="基础知识题型"></a>基础知识题型</h2><h3 id="为什么要使用数据库？"><a href="#为什么要使用数据库？" class="headerlink" title="为什么要使用数据库？"></a>为什么要使用数据库？</h3><p>使用数据库将数据永久的保存到磁盘中</p><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><p>SQL是结构化语句，用来对数据库数据的增删改查</p><h3 id="建表三范式？"><a href="#建表三范式？" class="headerlink" title="建表三范式？"></a>建表三范式？</h3><p>第一范式：每张表必须有主键，并且每一个字段是原子性不可再拆分。</p><p>第二范式：基于第一范式，所有非主键字段完全依赖主键，不能依赖主键的一部分，保证一张表只描述一件事情。</p><p>非主键如果没有完全依赖主键，这样会产生怎样的问题呢？</p><p>数据冗余：重复的数据多</p><p>插入异常：比如一场比赛，比如没有确定参赛的人员，就没有进行插入</p><p>删除异常：比如一场比赛我需要删除一个参赛人员，就同时就会把比赛信息删除掉</p><p>更新异常：如果我们要调整比赛的时间，就需要更改所有的这个比赛的时间，否则就会出现一场比赛出现比赛时间不同的情况。</p><p>第三范式：基于第二范式，所有非主键字段之间依赖主键，不要产生传递依赖，确保每个字段都和主键都有关系</p><p>根据三范式设计数据库可以避免表中数据的冗余，空间的浪费，在实际中，一般都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p><p>一对一：一张表中一条数据只能对应另一张表的一条的数据，给其中的一张表+外键+唯一约束unique，其实上语法跟多对多没有太大区别。</p><p>一对多：两张表，多的表多外键</p><p>多对多：三张表，关系表加外键，额外创建关系表存放两张表的id键值</p><p>下边的范式作为了解，范式等级越高，表的连接就会增多，从而会影响查询效率</p><p>巴斯范式</p><p>第四范式</p><p>第五范式</p><h3 id="基础数据类型？"><a href="#基础数据类型？" class="headerlink" title="基础数据类型？"></a>基础数据类型？</h3><p>整数类型</p><p>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字 节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整 数。</p><p>实数类型</p><p>FLOAT、DOUBLE、DECIMAL</p><p>DECIMAL可以用于存储比BIGINT还大的整型，能存储 精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p>字符串类型</p><p>VARCHAR、CHAR、TEXT、BLOBVARCHAR</p><p>BLOBVARCHAR用于存储可变长字符串，它比定长类型更 节省空间。 VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字 节表示。 VARCHAR存储的内容超出设置的长度时，内容会被截断。 CHAR是定长的，根据定义的字符串长度分配足够的空间。 CHAR会根据需要使用空格进行填充方便比较。 CHAR适合存储很短的字符串，或者所有值都接近同一个长度。 CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>使用策略</p><p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查 询时会使用临时表，导致严重的性能开销。</p><p>枚举类型（ENUM）</p><p>把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符 串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是 整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p><p>日期和时间类型</p><p>尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。 如果需要存储微妙，可以使用bigint存储。</p><h3 id="Mysql会产生几种日志？"><a href="#Mysql会产生几种日志？" class="headerlink" title="Mysql会产生几种日志？"></a>Mysql会产生几种日志？</h3><p>general log:记录客户端连接信息以及执行的SQL语句信息。</p><p>error log：错误日志，记录MYSQL在启动、关闭运行过程中的错误信息。</p><p>undo log：回滚日志，事务失败之后的回滚，mvcc访问老版本的数据（多版本并发控制下的读取）</p><p>redo log：重写日志，用于机器宕机导致事务失败来重新执行事务，来恢复在内存中还没有刷入磁盘中的那部分数据</p><p>binlog：以二进制的形式记录所有增删改，表操作的日志，作用：恢复数据，主从同步</p><p>slow query log：慢查询日志，记录查询时间较慢的SQL，默认不会开启慢查询日志，需要手动来设置这个参数。</p><h3 id="binlog日志的录入的几种方式？分别有什么区别？"><a href="#binlog日志的录入的几种方式？分别有什么区别？" class="headerlink" title="binlog日志的录入的几种方式？分别有什么区别？"></a>binlog日志的录入的几种方式？分别有什么区别？</h3><p>statement、row、mixed</p><p>statement(默认)：每条修改数据的sql语句记录在binlog日志中</p><p>优点：不记录每一行的变化，节约了IO，提高了性能。缺点：主从模式下会导致数据不一致，比如执行函数timestamp</p><p>row：记录每条SQL语句并且包含操作的具体数据</p><p>优点：不会出现某种特定使用函数的情况无法被正确复制的问题。缺点：会产生大量日志，alter table 日志会暴涨</p><p>mixed：statement和row的混合复制模式，对于使用statement无法复制的使用Row来复制。表结构的变化使用statement，如果是update和delete修改数据的语句使用row模式。</p><h3 id="MYSQL集群同步时为什么使用binlog？"><a href="#MYSQL集群同步时为什么使用binlog？" class="headerlink" title="MYSQL集群同步时为什么使用binlog？"></a>MYSQL集群同步时为什么使用binlog？</h3><p>1.支持所有的存储引擎使用</p><p>2.支持增量同步</p><p>3.还可以供其他中间件读取，比如同步到hdfs中</p><p>4.复制表数据，不支持回放，一旦中断复制很难确定复制的offset</p><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>三层：连接池，服务层，引擎层</p><p>1.客户端Client层：服务器之外的客户端程序，Native，JDBC等</p><p>2.服务器端MySQL Server层：下边的顺序是服务层各服务之间执行的顺序，服务层基础的服务组件包含：</p><p>​    2.1 连接池（连接层）Connection Pool：提供多个客户端与服务器连接的线程</p><p>​    2.2 SQL接口 SQL Interface：接收sql指令并且返回查询结果</p><p>​            执行到这里会先去缓存2.5查看，如果有缓存会直接将缓存的结果返回，如果没有执行2.3解析器来解析sql</p><p>​    2.3解析器 Parser：语法解析，语义解析，生成语法树，用来处理sql语句</p><p>​    2.4优化器 Optimlzer（核心组件）：是否需要使用索引，多表的样式，外连接的转换，这里有逻辑优化（sql语句）和物理优化（使用3索引的方式）</p><p>​    2.5查询缓存 Caches Buffers（Mysql8.0废除了，5.7继续保留）：key-value的方式缓存查询结果</p><p>3.存储引擎层：与底层的文件进行交互，有MyISum，InnoDB，Memory等多个存储引擎。</p><p>4.存储层：文件系统File system（会将数据加载到内存中，cpu然后去内存中查询，查询完之后会将数据缓存到2.5步骤缓存池），日志文件File &amp;Logs</p><h3 id="SQL的执行流程"><a href="#SQL的执行流程" class="headerlink" title="SQL的执行流程"></a>SQL的执行流程</h3><p>1.查询缓存，如果在查询缓存中发现了这条SQL，就将缓存的值直接返回客户端，存储的格式是key为sql语句，value为他的值。在MYSQL8.0之后抛弃了这个功能，因为在大多数情况查询缓存非常的鸡肋，命中率太低（比如在查询的时候有一个时间函数，不同的两次查询结果不同，如果在第一次缓存了，第二次直接使用的话就是错误的，缓存失效的情况出现在对表使用了INSERT、UPDATE、DELETE、DROP TABLE语句，对该表的数据从缓存中删除。</p><p>2.解析器：如果没有命中缓存开始执行sql语句，主要分为两步是词法分析（sql语句），语法分析（判断这个sql是否满足MYSQL语法），如果sql语法正确会生成一个语法树。</p><p>3.优化器：物理优化通过索引和表连接方式进行优化，逻辑优化通过SQL的写法方式来提升查询效率，最后会生成一个执行计划交给执行器，执行之前判断当前用户是否有执行的权限，如果有，就执行SQL查询返回结果，如果没有返回权限错误</p><p>如果有权限打开表继续执行，根据表的引擎定义，调用存储引擎API对表的读写，引擎API是一些接口，实际上的实现是插拔式的存储引擎MyISum，InnoDB等</p><p>如果在表中没有引擎就是一行一行的查找全表扫描</p><p>执行流程：SQL语句—–&gt;查询缓存—–&gt;解析器（语法分析，语义分析）——&gt;优化器（逻辑优化，物理优化）生成执行计划交给执行器—–&gt;执行器—–&gt;存储引擎API</p><h3 id="SQL执行原理"><a href="#SQL执行原理" class="headerlink" title="SQL执行原理"></a>SQL执行原理</h3><p>1.确认profiling是否开启</p><p>查询sql语句执行过程是否开启：select @@profiling或者show variables like ‘%profiling’ </p><p>2.查看执行过的语句记录</p><p>查看所有的记录show profiles;</p><p>查看最近一条show profile;</p><p>查看指定的一条show profile for query 6；</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>在服务层执行完查询优化之后，会根据生成的执行计划调用底层的存储引擎提供的api，获取到数据后返回给客户端</p><p>存储引擎就是表的类型，就是接受从上层传下来的指令，对表中的数据进行操作。</p><h3 id="存储引擎命令相关"><a href="#存储引擎命令相关" class="headerlink" title="存储引擎命令相关"></a>存储引擎命令相关</h3><p>查看所有引擎：show engines；</p><p>查看默认的存储引擎：show variables like ‘%storage_engine%’;</p><h3 id="常用的InnoDB和MyISAM的区别？"><a href="#常用的InnoDB和MyISAM的区别？" class="headerlink" title="常用的InnoDB和MyISAM的区别？"></a>常用的InnoDB和MyISAM的区别？</h3><p>外键：支持，不支持</p><p>事：支持，不支持</p><p>锁：InnoDB支持行锁粒度小，适合高并发，MyISAM支持行表锁粒度大，要锁定一条数据就要锁整个表，不适合高并发</p><p>缓存：InnoDB不仅缓存索引还要缓存真实数据，对内存要求高，MyISAM只缓存索引，不缓存真实数据</p><p>使用优势点：InnoDB事务，并发写，更大资源，MyISAM节省资源，消耗小，业务适合简单的</p><p>阿里使用的是自建的存储引擎:Xtradb并且在性能和并发做的更好</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引是存储引擎用于快速查找到数据的一种数据结构，也是存储引擎的实现，通过目录的方式可以快速的定位到需要的文章。</p><p>创建索引的目的是为了减少io的操作次数，因为在读取的过程中从磁盘数据较慢，而从内存中读取是非常的快，所以减少io的次数可以大幅度的提升查询效率</p><h3 id="索引的优点和缺点"><a href="#索引的优点和缺点" class="headerlink" title="索引的优点和缺点"></a>索引的优点和缺点</h3><p>优点</p><p>1.创建索引是为了磁盘的io成本次数</p><p>2.创建唯一索引可以保证数据库表中数据的唯一性</p><p>3.子表与父表联合查询可以提高效率，子表关联父表的主键id就能快速的查到</p><p>4.减少分组和排序的时间，因为使用了索引他本来就是有序的，分组的时候相同的一组已经排列到了一块所以比较开，排序索引本身自己就已经排好序了不用重新排序所以速度快，降低cpu消耗</p><p>缺点：</p><p>创建和维护索引耗费时间，数据的增加，耗时也会更长</p><p>占用磁盘空间，表空间，物理空间</p><p>虽然提高了查询的效率， 但是会降低我们的插入速度、删除、修改的速度，因为在插入数据的位置会将其他数据进行移动，索引需要动态的维护</p><p>注：如果在数据库表中频繁的操作删除，修改，要先将数据库表中的索引删除掉，然后执行完删改操作后，再进行一次创建索引，频繁的维护索引肯定会比一次性维护索引快的多</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="C:\Users\liulei\AppData\Roaming\Typora\typora-user-images\image-20230819173900158.png" alt="image-20230819173900158"></p><p><img src="C:\Users\liulei\AppData\Roaming\Typora\typora-user-images\image-20230819174045326.png" alt="image-20230819174045326"></p><p>实际的数据放在第0层也叫做叶子节点，假设每个叶子节点的数据页可以存放100条记录，目录项的内节点可以放1000条记录，那么：</p><p>如果B+树只有一层，最多能放一条记录</p><p>如果B+树有两层，最多能放100x1000=10,0000条数据</p><p>如果B+树有三层，最多能放100x1000x1000=1，0000，0000条数据</p><p>所以在一般的情况下，我所用到的B+树都不会超过4层，使用二分查找的方法</p><p>B+树索引的注意事项</p><p>1.根页面位置万年不动</p><p>刚开始的时候是存储节点数据，如果存储的数据超过这个页的最大容量，就会页分裂，出现内节点，然后将数据复制到内节点，当前的这个根充当一个目录项</p><p>2.内节点中记录项记录的唯一性</p><p>内节点的唯一性主要包含了 目录项，页数，主键id来组成的，这个是针对二级索引的</p><p>3.一个页面最少存储2条记录</p><p>一条记录没有办法使用二分法，所以最少保存2条记录</p><h3 id="索引的类型（数据的存储方式）"><a href="#索引的类型（数据的存储方式）" class="headerlink" title="索引的类型（数据的存储方式）"></a>索引的类型（数据的存储方式）</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>主键构建的这个索引叫聚簇索引，非主键构建的这个索引叫非聚簇索引</p><p>聚簇索引不是单独的索引类型结构，是一种存储方式，比如在叶子节点存放的用户记录，索引即数据，数据即索引</p><p>聚簇表示数据行和相邻的键值聚簇的存储在一起</p><p>优点</p><p>不需要显式的使用INDEX语句创建，innodb会自动为我们创建聚簇索引</p><p>查询数据较快，因为聚簇索引将索引和数据保存在同一个B+树中，所以聚簇索引比在非聚簇索引中查询速度快</p><p>对于主键的排序查找和范围查找速度非常快</p><p>节省IO操作</p><p>缺点</p><p>插入速度依赖于插入的顺序，否则将会出现页分裂，严重影响性能，一般会定义一个有序的ID列为主键</p><p>更新的代价很大，会导致更新的行移动，一般定义为主键不可更新</p><p>二级索引需要访问两次索引查找，第一找到主键值，第二次根据主键值到行数据</p><p>限制</p><p>只有innodb支持聚簇索引</p><p>表只能有一个聚簇索引，跟主键是一对一的关系</p><p>主键尽量使用有序的id，避免使用uuid，md5，hash，字符串无法保证顺序的值</p><h4 id="二级索引-辅助索引，非聚簇索引"><a href="#二级索引-辅助索引，非聚簇索引" class="headerlink" title="二级索引(辅助索引，非聚簇索引)"></a>二级索引(辅助索引，非聚簇索引)</h4><p>在一张表中只有一个聚簇索引，可以有多个二级索引也叫做非聚簇索引</p><p>二级索引就是使用非主键的其他字段和主键字段构建的，需要进行回表查询</p><p>回表的概念？</p><p>首先是根据其他字段的值来构建的B+树结果，首先通过二分法找到这个叶子节点，然后通过叶子节点找到主键ID，然后根据组件ID再去聚簇索引里边重新查找叶子节点的数据，这个过程叫做回表</p><h4 id="联合索引（非聚簇索引）"><a href="#联合索引（非聚簇索引）" class="headerlink" title="联合索引（非聚簇索引）"></a>联合索引（非聚簇索引）</h4><p>基于两个字段，先使用第一个字段排序，然后在依次使用第二个字段</p><h3 id="存储引擎MyISAM"><a href="#存储引擎MyISAM" class="headerlink" title="存储引擎MyISAM"></a>存储引擎MyISAM</h3><p>非聚簇索引，索引文件只保存数据记录的地址</p><p>索引B-Tree其实就是B+Tree，在国内才这么区分的</p><p>MyISAM引擎使用B+Tree作为索引结构，叶子结构存放的data结构是数据记录的地址，叶子结点存放地址还是真实的数据取决于是聚簇索引还是非聚簇索引。</p><p>MyISAM与InnoDB对比</p><p>索引方式：MyISAM的索引方式都是非聚簇索引的，InnoDB包含一个聚簇索引，也可以是非聚簇索引的</p><p>查找过程：在Innodb中主需要根据主键id就可以在叶子节点中找到想要的数据，在MyISAM中需要一次回表，意味着MyISAM全都是二级索引或是非聚簇索引</p><p>文件类型：Innodb的数据文件就是索引文件，而MyISAM的数据文件和索引文件是分离的，索引文件里记录着索引数据的地址值</p><p>速度：MyISAM的回表操作查找地址是非常快的，Innodb根据主键获取的，很明显是比不过的地址访问的</p><p>MyISAM可以没有主键，Innodb必须得指定主键</p><h3 id="为什么不建议使用较长的字段作为索引？"><a href="#为什么不建议使用较长的字段作为索引？" class="headerlink" title="为什么不建议使用较长的字段作为索引？"></a>为什么不建议使用较长的字段作为索引？</h3><p>因为每个页的大小是16kb，如果字段较长占用的空间就多了，存储的数据就少了，页分裂的次数也就多了</p><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><p>空间上的代价</p><p>每建立一个索引都要为她建立一颗B+树，每一颗树的每个节点都是一个数据页，每个数据页16kb，一颗B+树由需要的页组成，所以占很大的空间</p><p>时间上的代价</p><p>对数据进行增删改的时候，都要去修改各个B+树索引，B+树的每个节点都是按照从小到大排序的形成了双向链表，而增删改会对节点的记录顺序造成破坏，所以存储引擎也需要额外的一些记录位移，页面分裂，页面回收等操作来维护好节点和记录的顺序，会给性能拖后腿</p><h3 id="Hash索引、二叉搜索树、AVL树、B-Tree、B-Tree、R树"><a href="#Hash索引、二叉搜索树、AVL树、B-Tree、B-Tree、R树" class="headerlink" title="Hash索引、二叉搜索树、AVL树、B-Tree、B+Tree、R树"></a>Hash索引、二叉搜索树、AVL树、B-Tree、B+Tree、R树</h3><p> Hash索引结构主要是对于等值查询，是Memory的默认存储引擎</p><p>二叉搜索树利用二叉树为索引结构，IO的次数和树的高度有关，为了减少IO的次数，需要尽量降低树的高度。每层的分叉越多越好，然后演变成了AVL树</p><p>AVL树为了解决二叉树查找树化成链表的问题，又称平衡二叉搜索树，需要5次IO操作</p><p>B-Tree多路平衡查找树 ，相对于平衡二叉树来说IO操作要少</p><p>1.B数在插入和删除节点的时候如果导致树不平衡，会自动调整节点的位置来保持数的平衡</p><p>2.在叶子节点和非叶子节点都存放数据，搜索可能在非叶子节点结束</p><p>B+Tree也是一颗多路搜索树，基于B数进行改进，更适合文件索引系统</p><p>B+Tree和B-Tree的查询过程差不多，根本的差异在于B+的内节点不直接存储数据，查询效率稳定，效率更高</p><p>为了减少IO，索引树会一次性加载吗？</p><p>数据库索引是存在硬盘上的，如果数据量大，索引的大小的也会很大，当我们查找的时候，不可能将全部的几个G的索引都加载到内存，逐一加载这个磁盘页</p><p>B+数存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</p><p>为什么说B+树比B-树更适合在实际应用中操作系统的文件索引和数据库索引？</p><p>1.B+树的磁盘读写代价低</p><p>2.B+树的查询效率更稳定</p><p>Hash索引与B+树索引的区别？</p><p>1.Hash索引不能进行范围查询，而B+树可以</p><p>2.Hash索引不支持联合索引的最左侧原则（联合索引无法使用）</p><p>3.Hash不支持ORDER BY排序</p><p>4.Innodb不支持hash索引</p><p>R树，R-TREE在MYSQL中很少使用，仅支持geometry数据类型，解决高纬度空间搜索问题，并且支持MyISAM，InnoDB，应用在谷歌，百度地图这种超大数据库中</p><h3 id="Innodb的存储结构（先了解）"><a href="#Innodb的存储结构（先了解）" class="headerlink" title="Innodb的存储结构（先了解）"></a>Innodb的存储结构（先了解）</h3><h4 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h4><p>索引结构都是保存在文件上的，存储在页结构中。索引是在存储引擎中实现的，存储引擎是负责对表数据得到读取和写入工作，不同的存储引擎中存放的格式是不同的。</p><h4 id="磁盘与内存交互的基本单位：页"><a href="#磁盘与内存交互的基本单位：页" class="headerlink" title="磁盘与内存交互的基本单位：页"></a>磁盘与内存交互的基本单位：页</h4><p>Innodb将数据划分为若干个页，每页的大小默认为16KB </p><p>在数据库中，不论是读一行，还是读多行，都是将这些行所在的页进行加载，也就是说，数据库管理存储空间的基本单位是页，数据I/O操作操作的最小单位是页</p><h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>区(Extent)是比页大一级的存储结构,在InnoDB存储引擎中,一个区会分配64个连续的页。因为InnoDB中的页大小默认是 16KB，所以一个区的大小是 64*16KB= 1MB</p><p>段(Segment)由一个或多个区组成,区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页) ,不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位,不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候,就会相应创建对应的段,比如创建一张表时会创建一个表段,创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成,表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p><h2 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p> MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><p>从功能逻辑 上说，索引主要有 4种，分别是普通索引、唯一索引、主键索引、全文索引。</p><p>按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。</p><p>按照、作用字段个数 进行划分，分成单列索引和联合索引。</p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 任何数据类型 中，其值是否唯一和非空,要由字段本身的完整性约束条件决定。建立索引以后,可以通过索引进行查询。例如,在表student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>使用 UNIQUE参数可以设置索引为唯一性索引,在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p><p>例如,在表student的字段email 中创建唯一性索引,那么字段email的值就必须是唯一的。通过唯一性索引,可以更快速地确定某条记录。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引就是一种 特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。</p><p>Why? 这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><h4 id="单例索引"><a href="#单例索引" class="headerlink" title="单例索引"></a>单例索引</h4><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引,还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><h4 id="多列-组合、联合-索引"><a href="#多列-组合、联合-索引" class="headerlink" title="多列(组合、联合)索引"></a>多列(组合、联合)索引</h4><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段,可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id,name和gender上建立一个多列索引idx_id_name_gender ,只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性,然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集,对于小的数据集,它的用处比较小。</p><h4 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h4><p> 使用 参数SPATIAL 可以设置索引为 空间索引 。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、 POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>不同的存储引擎支持的索引类型也不一样</p><p>InnoDB :支持 B-tree, Full-text等索引,不支持Hash索引;</p><p>MyISAM：支持 B-tree、Full-text 等索引，不支持 Hash 索引;</p><p>Memory : 支持 B-tree、Hash 等索引,不支持 Full-text 索引;</p><p>NDB :支持 Hash索引,不支持 B-tree、 Full-text 等索引;</p><p>Archive :不支持B-tree, Hash, Full-text等索引;</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>MySQL支持多种方法在单 个或多个列上创建索引:</p><p>在创建表的定义语句CREATE TABLE中指定索引列</p><p>使用ALTER TABLE语句在存在的表上创建索引</p><p>或者使用CREATE INDEX语句在已存在的表上添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#隐式的方式创建索引，声明有主键约束、唯一约束、外键约束的字段上，会自动添加相关的索引`</span><br><span class="line">`CREATE TABLE dept (` </span><br><span class="line">`dept_id INT PRIMARY KEY AUTO_INCREMENT,`</span><br><span class="line">`demp_name VARCHAR ( 20 )`</span><br><span class="line">`);`</span><br><span class="line"></span><br><span class="line">`CREATE TABLE emp(`</span><br><span class="line">`emp_id INT PRIMARY KEY AUTO_INCREMENT,`</span><br><span class="line">`emp_name VARCHAR(20) UNIQUE,`</span><br><span class="line">`dept_id INT,`</span><br><span class="line">`CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)`</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="数据库服务器优化步骤"><a href="#数据库服务器优化步骤" class="headerlink" title="数据库服务器优化步骤"></a>数据库服务器优化步骤</h3><p>查看服务器是否存在周期性波动的情况，如果存在波动性比较大的情况下，如双十一可以加缓存更改缓存失效策略</p><p>如果不是服务器周期性波动的情况，仍有延迟卡顿的问题，开启开启慢查询（超过阈值，将相关sql记录在日志中）</p><p>找到查询慢的sql语句就可以使用EXPLAN查看具体的执行计划，或者通过SHOW PROFILING 来查询具体步骤的时间成本 ，可以看出到底是sql执行时间长还是等待时间长导致的慢查询，如果是等待时间比较长的话可以调优服务器参数，如果是执行时间长，考虑索引优化、join表，数据库设计</p><p>如果SQL查询达到瓶颈，可以通过读写分离（主从架构）、分库分表（垂直分库，垂直分库，水平分表）</p><p>调优顺序：SQL及索引，数据库表结构，系统配置，硬件</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p> 慢查询日志用来记录MYSQL中响应运行时间（long_query_time）超过阈值的语句。默认情况下，MYSQL数据库没有开启慢查询日志，需要手动设置这个参数。如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询会或多或少带来一定的性能影响，慢查询日志支持将日志写入文件</p><h3 id="EXPLAN的使用"><a href="#EXPLAN的使用" class="headerlink" title="EXPLAN的使用"></a>EXPLAN的使用</h3><p>定位了慢SQL语句，可以通过EXPLAN或DESCRUBE工具做针对性的分析查询语句，他两语法是相同的。</p><p>提供最优的执行计划</p><p>作用？</p><p>表的读取顺序</p><p>数据读取操作的操作类型</p><p>哪些索引可以实用</p><p>哪些索引被实际使用</p><p>表之间的引用</p><p>每张表有多少行被优化器执行</p><p>版本情况：5.6.3之前只有SELECT可以用EXPLAN，5.6.3之后SELECT、UPDATE、DELETE也可以用了</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM pms_attr;</span><br><span class="line"></span><br><span class="line">DESCRIBE SELECT * FROM pms_attr;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">列名</th><th>描述</th></tr></thead><tbody><tr><td align="left">id</td><td>一个大的查询语句中每个SELECT关键字对应一个唯一相同的id，如果有两个以上的SELECT，他们的id就不相同，查询优化器可能对涉及子查询的语句进行重写，转化为多表查询的操作，Union去重取并集，会有临时表，Union不去重</td></tr><tr><td align="left">select_type</td><td>查询的类型，小查询在大查询中扮演的一个什么角色，简单的查询类型就是SIMPLE，其他的类型可以百度查阅</td></tr><tr><td align="left">table</td><td>查询的表名，sql里有几张表就有几条记录</td></tr><tr><td align="left">partitions</td><td>匹配的分区信息</td></tr><tr><td align="left">type</td><td>单表的访问方法,又称访问类型</td></tr><tr><td align="left">possible_keys</td><td>可能用到的索引，一般查询涉及到的字段都会被列出来</td></tr><tr><td align="left">key</td><td>真正使用的索引，在可能用到的索引possible_keys中选取一个</td></tr><tr><td align="left">key_len</td><td>实际使用到的索引长度（联合索引有一定的参考意义）单位:字节</td></tr><tr><td align="left">ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td align="left">rows</td><td>预估的需要读取的记录条数</td></tr><tr><td align="left">filtererd</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td align="left">Extra</td><td>一些额外的信息</td></tr></tbody></table><p>id相同，可以认为是一组，从上往下顺序执行</p><p>所有组中，id值越大，优先级越高，越先执行</p><p>每个id号码代表一趟独立的查询，一个sql的查询趟数越少越好</p><p>type</p><p>结果值从最好到最坏依次是： system, const, eq_ref, ref, fulltext, ref_or_null, index_mergeunique_subquery, index_subquery, range, index, ALL。</p><p>当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system，比如MYISAM，Memory</p><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p>提高性能最有效的方式是对数据表设计合理的索引</p><p>1.使用索引可以快速地定位表中的某条记录</p><p>2.如果没有使用索引，查询语句就会扫描表中的所有记录</p><p>默认情况下都采用B+树构建索引，空间类型的索引使用R-树，并且MEMORY表支持hash索引</p><p>用不用索引都取决于优化器，SQL语句是否使用索引，跟数据库版本，数据量，数据选择度都有关系</p><h4 id="失效的情况"><a href="#失效的情况" class="headerlink" title="失效的情况"></a>失效的情况</h4><p>1.全值匹配</p><p>2.最左前缀原则</p><p>多个字段创建索引，一个索引包括16个字段，对于多列索引必须按照索引建立的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法使用，如果查询条件中没有用这些字段中第一个字段时，联合索引不会被使用</p><p>3.主键插入顺序</p><p>插入的主键值依次递增</p><p>4.计算、函数</p><p>5.类型转换（自动或手动）导致索引失效</p><p>6.范围条件右边的列索引失效（创建的联合索引，范围字段务必要写到最右边）</p><p>7.不等于会导致索引失效</p><p>8.is null 可以使用索引，is not null无法使用索引</p><p>9.like以通配符%开头索引失效（页面搜索禁止左模糊或者全模糊）</p><p>10.OR 前后存在非索引的列，索引失效</p><p>11.数据库和表的字符集统一使用utf8mb4，不同的字符进行比较转换会造成索引失效</p><p>一般建议：</p><p>对于单列索引，尽量选择针对当前query过滤性更好的索引在选择组合索引的时候,当前query中过滤性最好的字段在索引字段顺序中,位置越靠前越好。</p><p>在选择组合索引的时候,尽量选择能够包含当前query中的where子句中更多字段的索引。</p><p>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</p><h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><p>情况1 左外连接</p><p>驱动表与被驱动表，循环一次驱动表，被驱动表就得全部循序一遍 ，一般情况在被驱动表上加索引</p><p>情况2 内连接</p><p>1.对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现</p><p>2.如果只能有一个字段有索引，有索引字段所在的表会被作为被驱动表</p><p>3.两个表都存在索引的情况下，小表驱动大表</p><h3 id="JOIN语句的底层原理"><a href="#JOIN语句的底层原理" class="headerlink" title="JOIN语句的底层原理"></a>JOIN语句的底层原理</h3><p>join连接多个表，各个表之间数据的循环匹配</p><p>驱动表和被驱动表：驱动表就是主表，被驱动表就是从表，非驱动表</p><p>1.整体效率比较：INLJ -&gt;BNLJ -&gt;SNLJ，8.0废弃了BNLJ，加入hash join</p><p> 2.小表驱动大表这句话不精确，永远用小的结果集驱动大的结果集（针对没有索引的情况）</p><p>3.为被驱动表的条件增加索引，减少内存表的循环匹配次数</p><p>4.增大join buffer size的大小，一次缓存的数据越多，内层报的扫描次数越少</p><p>5.减少驱动表不必要的字段查询，字段越少，join buffer所缓存的数据就越多<br>6.不建议使用子查询，建议将子查询SQL拆开结果程序多次查询，或使用JOIN来代替子查询</p><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询的执行效率不高，需要为内层查询语句的查询结果建立一个临时表，查询完毕之后，再撤销临时表，这样会消耗过多的CPU和IO资源，产生大量的慢查询</p><p>子查询 不论是内存临时表还是磁盘临时表都不会存在索引，查询性能会受到一定的影响</p><p>返回的结果集比较大的子查询，对查询的性能也大，所以在MYSQL中可以使用JOIN来代替子查询</p><p>尽量不要使用NOT IN 或者 NOT EXISTS,用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p><p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。</p><p>Index排序中,索引可以保证数据的有序性,不需要再进行排序,效率更高。</p><p>FileSort 排序则一般在 内存中进行排序，占用 CPU较多。如果待排结果较大，会产生临时文件1/0 到磁盘进行排序的情况，效率较低。</p><p>两个索引同时存在，mysql自动选择最优的方案。</p><p>当【范围条件】和【group by或者 order by】的字段出现二选一时,优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</p><p>优化建议</p><p>1.SQL中,可以在WHERE子句和ORDER BY子句中使用索引,目的是在WHERE子句中避免全表扫描,在ORDER BY 子句 避免使用 FileSort 排序。当然,某些情况下全表扫描,或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p><p>2.尽量使用Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列; 如果不同就使用联合索引。</p><p>3.无法使用Index时,需要对FileSort方式进行调优。</p><p>filesort算法：双路排序和单路排序</p><p>双路排序（慢）</p><p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段。取一批数据,要对磁盘进行两次扫描,众所周知, 10是很耗时的,所以在mysql4.1之后,出现了第二种改进的算法，就是单路排序。</p><p>单路排序（快）</p><p>从磁盘读取查询需要的 所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些,避免了第二次读取数据。并且把随机10变成了顺序10,但是它会使用更多的空间,因为它把每一行都保存在内存中了。</p><p>如果要使用FileSort需要进行调优，改变sort_buffer_size的大小</p><p>尝试提高max_length_for_sort_data</p><p>Order by 时select *是一个大忌。最好只Query需要的字段。</p><h3 id="Group-By优化"><a href="#Group-By优化" class="headerlink" title="Group By优化"></a>Group By优化</h3><p>group by 使用索引的原则几乎跟order by一致，group by 即使没有过滤条件用到索引，也可以直接使用索引。</p><p>group by 先排序再分组,遵照索引建的最佳左前缀法则当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置where效率高于having，能写在where限定的条件就不要写在having中了减少使用order by,和业务沟通能不排序就不排序,或将排序放到程序端去做。</p><p>Order by,group by,distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p><p>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p><h3 id="Limit优化"><a href="#Limit优化" class="headerlink" title="Limit优化"></a>Limit优化</h3><p>一般分页查询时,通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是limit 2000000,10,此时需要MySQL排序前2000010记录,仅仅返回2000000-2000010的记录,其他记录丢弃,查询排序的代价非常大。</p><p>优化思路:</p><p>1.在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><p>2.适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><p>3.优先使用覆盖索引</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>要查询的字段正好是查询条件中建立了索引的字段，无需回表查询</p><p>好处：</p><p>1.避免Innodb表进行索引的二次查询(回表)Innodb是以聚集索引的顺序来存储的,对于Innodb来说,二级索引在叶子节点中所保存的是行的主键信息,如果是用二级索引查询数据,在查找到相应的键值后,还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p><p>2.可以把随机10变成顺序10加快查询效率由于覆盖索引是按键值的顺序存储的,对于10密集型的范围查找来说,对比随机从磁盘读取每一行的数据10要少的多,因此利用覆盖索引在访问时也可以把磁盘的 随机读取的I0 转变成索引查找的顺序IO。由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><p>弊端：</p><p>索引字段的维护总是有代价的。因此,在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA,或者称为业务数据架构师的工作。</p><h3 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a>索引条件下推</h3><p>在存储引擎层使用索引过滤数据的优化方式，通俗的讲就是通过二级索引查询的时候先不去回表查询，先根据后边的索引条件进行筛选之后，然后再进行查询，这样会减少回表查询的次数，从而提升效率</p><p>1.如果表访问的类型为range、 ref, eq_ref和ref_or_null可以使用ICP</p><p>2.ICP可以用于InnoDB和MyISAM表,包括分区表InnoDB和MyISAM表</p><p>3.对于InnoDB表, ICP仅用于二级索引。ICP的目标是减少全行读取次数,从而减少1/O操作。</p><p>4.当SQL使用覆盖索引时,不支持ICP。因为这种情况下使用ICP不会减少1/O。</p><p>5.相关子查询的条件不能使用ICP</p><h3 id="其他查询优化策略"><a href="#其他查询优化策略" class="headerlink" title="其他查询优化策略"></a>其他查询优化策略</h3><h4 id="EXISTS和IN的区分"><a href="#EXISTS和IN的区分" class="headerlink" title="EXISTS和IN的区分"></a>EXISTS和IN的区分</h4><p>小表驱动大表</p><p>驱动表小于非驱动表用EXISTS，非驱动表小于驱动表用EXISTS</p><h4 id="COUNT-与COUNT-具体字段-效率"><a href="#COUNT-与COUNT-具体字段-效率" class="headerlink" title="COUNT(*)与COUNT(具体字段)效率"></a>COUNT(*)与COUNT(具体字段)效率</h4><p>在MySQL中统计数据表的行数,可以使用三种方式: SELECT COUNT()、SELECT COUNT(1)和SELECTCOUNT(具体字段)，使用这三者之间的查询效率是怎样的？答：前提:如果你要统计的是某个字段的非空数据行数,则另当别论,毕竟比较执行效率的前提是结果一样才可以。</p><p>环节1: COUNT()和COUNT(1)都是对所有结果进行COUNT , COUNT()和COUNT(1)本质上并没有区别(二者执行时间可能略有差别,不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句,则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句,则是对数据表的数据行数进行统计。</p><p>环节2:如果是MyISAM存储引擎,统计数据表的行数只需要0(1)的复杂度,这是因为每张MyISAM的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是InnoDB 存储引擎，因为InnoDB 支持事务,采用行级锁和 MVCC机制,所以无法像MyISAM 一样，维护一个row_count变量，因此需要采用扫描全表，是 0(n） 的复杂度，进行循环 + 计数的方式来完成统计。</p><p>环节3:在InnobB引擎中,如果采用COUNT(具体字段)来统计数据行数,要尽量采用二级索引。因为主键采用的索引是聚簇索引,聚簇索引包含的信息多,明显会大于二级索引(非聚簇索引)。对于COUNT()和 COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会 自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引,会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候,才会采用主键索引来进行统计。</p><h4 id="关于SELECT"><a href="#关于SELECT" class="headerlink" title="关于SELECT(*)"></a>关于SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用<em>作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</em></p><p><em>① MySQL 在解析的过程中，会通过查询数据字典将”</em>“按序转换成所有列名，这会大大的耗费资源和时间。</p><p>②无法使用 覆盖索引</p><h4 id="LIMIT-对优化的影响"><a href="#LIMIT-对优化的影响" class="headerlink" title="LIMIT 对优化的影响"></a>LIMIT 对优化的影响</h4><p>针对的是会扫描全表的SQL语句,如果你可以确定结果集只有一条,那么加上LIMIT 1的时候,当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT1了。</p><h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>只要有可能,在程序中尽量多使用COMMIT,这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><p>回滚段上用于恢复数据的信息</p><p>被程序语句获得的锁</p><p>redo / undo log buffer 中的空间</p><p>管理上述 3 种资源中的内部花费</p><h3 id="淘宝数据库的主键是如何设计的？"><a href="#淘宝数据库的主键是如何设计的？" class="headerlink" title="淘宝数据库的主键是如何设计的？"></a>淘宝数据库的主键是如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单,其他都是缺点，总体来看存在以下几方面的问题：</p><p>1.可靠性不高存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p><p>2.安全性不高对外暴露的接口可以非常容易猜测对应的信息。比如: /User/1/这样的接口,可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p><p>3.性能差自增ID的性能较差,需要在数据库服务器端生成</p><p>4.交互多业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值,这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p><p>5.局部唯一性最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p><p>设计主键</p><p>非核心业务:对应表的主键自增ID,如告警、日志、监控等信息。</p><p>核心业务：主键设计至少应该是全局唯一且是单调递增。</p><p>推荐最简单的一种主键设计：UUID</p><p>UUID：全局唯一、占用36字节，数据无序，插入性能差</p><p>UUID的组成：UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） -MAC地址（12字节）</p><p><img src="C:\Users\liulei\AppData\Roaming\Typora\typora-user-images\image-20230831230529879.png" alt="image-20230831230529879"></p><p>为什么UUID是全局唯一的？</p><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00: 00: 00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高,时间维度发生重复的概率降低到1/100ns。时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p><p>为什么UUID占用36个字节？</p><p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p><p>为什么UUID是随机无序的呢？</p><p>因为UUID的设计中,将时间低位放在最前面,而这部分的数据是一直在变化的,并且是无序。</p><h4 id="改造UUID"><a href="#改造UUID" class="headerlink" title="改造UUID"></a>改造UUID</h4><p>若将时间高低位互换,则时间就是单调递增的了,也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式,这样UUID就是有序的UUID了。MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>通过函数uuid_to_bin(@uuid,true）将UUID转化为有序UUID了，全局唯一 + 单调递增，这就是我们想要的主键</p><h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><p>ER模型也叫实体关系模型，用来描述现实生活中客观存在的事物，事务的属性，以及事务之间关系的一种数据模型。</p><p>ER模型中有三个要素：实体、属性、关系</p><p>实体：数据对象，用矩形来表示，分表是强实体（不依赖其他实体的实体）和弱实体（对另一个实体有很强的依赖关系的实体）</p><p>属性：指实体的特性属性，比如个人信息等，用椭圆形来表示</p><p>关系：实体之间的联系，使用菱形来表示</p><p>关系的类型：一对一，一对多，多对多，一对一比如是自己的身份信息是唯一一条，一对多是一个班级对应多个学生，多对多是比如超市可以有多个供应商，供应商也可以有多个超市</p><h3 id="ER模型转换成数据表"><a href="#ER模型转换成数据表" class="headerlink" title="ER模型转换成数据表"></a>ER模型转换成数据表</h3><p>一个实体通常转换成一个数据表</p><p>属性转换成表中的字段</p><p>一个多对多之间的关系，通常转换成一个数据表，也叫中间表</p><p>一个一对一，或者一对多的关系，通常使用外键来连接，在实际的项目中是不建议使用外键的，一方面是降低开发的复杂度（有外键的话主从表必须先操作主表，另外处理外键的时候非常麻烦），业务并发量大一般不设置外键，以免影响数据库性能，在应用的层面保证数据的一致性检查就可以，做的是逻辑外键不是物理外键，直接在从表查询自己想要的数据即可</p><h3 id="创建RE模型的工具：PowerDesigner"><a href="#创建RE模型的工具：PowerDesigner" class="headerlink" title="创建RE模型的工具：PowerDesigner"></a>创建RE模型的工具：PowerDesigner</h3><h2 id="数据库的设计原则与日常编写SQL规范"><a href="#数据库的设计原则与日常编写SQL规范" class="headerlink" title="数据库的设计原则与日常编写SQL规范"></a>数据库的设计原则与日常编写SQL规范</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>1.数据表的个数越少越好</p><p>2.数据表的字段个数越少越好</p><p>3.数据表中联合主键的字段个数越少越好</p><p>设置主键是为了确定唯一性,当一个字段无法确定唯一性的时候,就需要采用联合主键的方式(也就是用多个字段来定义一个主键)。联合主键中的字段越多,占用的索引空间越大,不仅会加大理解难度,还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p><p>4.使用主键和外键越多越好</p><p>“三少一多”原则的核心就是 简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多,证明它们之间的利用率越高。</p><h3 id="SQL规范"><a href="#SQL规范" class="headerlink" title="SQL规范"></a>SQL规范</h3><h4 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h4><p>1.【强制】库的名称必须控制在32个字符以内,只能使用英文字母、数字和下划线,建议以英文字母开头。</p><p>2.【强制】库名中英文 一律小写，不同单词采用 下划线 分割。须见名知意。</p><p>3.【强制】库的名称格式:业务系统名称-子系统名。</p><p>4.【强制】库名禁止使用关键字（如type,order等)。</p><p>5.【强制】创建数据库时必须显式指定字符集,并且字符集只能是utf8或者utf8mb4.</p><p>创建数据库SQL举例: CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</p><p>6.【建议】对于程序连接数据库账号,遵循权限最小原则使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限。</p><p>7.【建议】临时库以tmp_为前缀,并以旧期为后缀;备份库以bak_为前缀，并以日期为后缀。</p><h4 id="关于表"><a href="#关于表" class="headerlink" title="关于表"></a>关于表</h4><p>1.【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线,建议以 英文字母开头。</p><p>2.【强制】表名、列名一律小写，不同单词采用下划线分割。须见名知意。</p><p>3.【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀。比如： crm_fund_item</p><p>4.【强制】创建表时必须 显式指定字符集为utf8或utf8mb4。</p><p>5.【强制】表名、列名禁止使用关键字(如type,order等) 。</p><p>6.【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求,一律为InnoDB</p><p>7.【强制】建表必须有comment。</p><p>8.【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写。如:公司ID,不要使用corporation_id,而用corp_id 即可。</p><p>9.【强制】布尔值类型的字段命名为is_描述。如member表上表示是否为enabled的会员的字段命名为is_enabled。</p><p>10.【强制】禁止在数据库中存储图片、文件等大的二进制数据通常文件很大,短时间内造成数据量快速增长,数据库进行数据库读取时,通常会进行大量的随机10操作,文件很大时，I0操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p><p>11.【建议】建表时关于主键:表必须有主键(1)强制要求主键为id,类型为int或bigint,且为auto_increment建议使用unsigned无符号型。(2)标识表里每一行主体的字段不要设为主键,建议设为其他字段如user_id, order_id等,并建立unique key索引。因为如果设为主键且主键值为随机插入,则会导致innodb内部页分裂和大量随机1/O,性能下降。</p><p>12.【建议】核心表(如用户表)必须有行数据的创建时间字段(create_time)和最后更新时间字段(update_time) ,便于查问题。</p><p>13.【建议】表中所有字段尽量都是 NOT NULL属性,业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p><p>14.【建议】所有存储相同数据的 列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p><p>15.【建议】中间表(或临时表)用于保留中间结果集,名称以tmp_开头。备份表用于备份或抓取源表快照,名称以bak_开头。中间表和备份表定期清理。</p><h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><p>1.【强制】 InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新。</p><p>2.【强制】 InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE。</p><p>3.【建议】主键的名称以pk_开头，唯一键以uni_或uk_开头，普通索引以idx_开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p><p>4.【建议】多单词组成的columnname，取前几个单词首字母,加末单词组成column_name。如: sample 表member_id 上的索引: idx_sample_mid。</p><p>5.【建议】单个表上的索引个数不能超过6个。</p><p>6.【建议】在建立索引时,多考虑建立联合索引,并把区分度最高的字段放在最前面。</p><p>7.【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p><p>8.【建议】建表或加索引时，保证表里互相不存在冗余索引。比如:如果表里已经存在key(a,b),则key(a)为冗余索引,需要删除。</p><h4 id="SQL编写"><a href="#SQL编写" class="headerlink" title="SQL编写"></a>SQL编写</h4><p>1.【强制】程序端SELECT语句必须指定具体字段名称，禁止写成*。</p><p>2.【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p><p>3.【建议】除静态表或小表(100行以内) , DML语句必须有WHERE条件,且使用索引查找。</p><p>4.【建议】INSERT INTO…VALUES(XX),(XX),(XX)..这里XX的值不要超过5000个。值过多虽然上线很快，但会引起主从同步延迟。</p><p>5.【建议】 SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p><p>6.【建议】线上环境，多表 JOIN 不要超过5个表。</p><p>7.【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p><p>8.【建议】包含了ORDER BY, GROUP BY, DISTINCT这些查询的语句, WHERE条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p><p>9.【建议】对单表的多次alter操作必须合并为一次对于超过100w行的大表进行alter table,必须经过DBA审核,并在业务低峰期执行,多个alter需整合在一起。因为alter table会产生表锁,期间阻塞对于该表的所有写入,对于业务可能会产生极大影响。</p><p>10.【建议】批量操作数据时,需要控制事务处理间隔时间,进行必要的sleep。</p><p>11.【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久,MySQL内部缓存、连接消耗过多等问题。</p><ol start="12"><li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY,如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ol><h2 id="数据库调优整体步骤"><a href="#数据库调优整体步骤" class="headerlink" title="数据库调优整体步骤"></a>数据库调优整体步骤</h2><h3 id="第一步，选择适合的DBMS"><a href="#第一步，选择适合的DBMS" class="headerlink" title="第一步，选择适合的DBMS"></a>第一步，选择适合的DBMS</h3><p>如果对事务性处理以及安全性要求高的话,可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强,比如采用SQL Server, Oracle,那么单表存储上亿条数据是没有问题的。如果数据表设计得好,即使不采用分库分表的方式,查询效率也不差。</p><p>除此以外,你也可以采用开源的MySQL进行存储,它有很多存储引擎可以选择,如果进行事务处理的话可以选择InnoDB,非事务处理可以选择MyISAM。</p><p>NoSQL 阵营包括 键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同,比如列式存储数据库可以大幅度降低系统的1/0,适合于分布式文件系统,但如果数据需要频繁地增删改,那么列式存储就不太适用了。</p><p>DBMS的选择关系到了后面的整个设计过程,所以第一步就是要选择适合的DBMS。如果已经确定好了DBMS,那么这步可以跳过。</p><h3 id="第二步，优化表设计"><a href="#第二步，优化表设计" class="headerlink" title="第二步，优化表设计"></a>第二步，优化表设计</h3><p>选择了DBMS之后,我们就需要进行表设计了。而数据表的设计方式也直接影响了后续的SQL查询语句。RDBMS中,每个对象都可以定义为一张表,表与表之间的关系代表了对象之间的关系。如果用的是MySQL,我们还可以根据不同表的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考：</p><p>1.表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范,减少冗余字段,同时也减少了在更新,插入和删除数据时等异常情况的发生。</p><p>2.如果查询应用比较多,尤其是需要进行多表联查的时候,可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</p><p>3.表字段的数据类型选择,关系到了查询效率的高低以及存储空间的大小。一般来说,如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR类型;当长度不固定时,通常采用VARCHAR类型。数据表的结构设计很基础,也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用,不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</p><h3 id="第三步，优化逻辑查询"><a href="#第三步，优化逻辑查询" class="headerlink" title="第三步，优化逻辑查询"></a>第三步，优化逻辑查询</h3><p>当我们建立好数据表之后,就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。SQL查询优化,可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变SQL语句的内容让SQL执行效率更高效，采用的方式是对 SQL 语句进行等价变换，对查询进行重写。SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等。比如我们在讲解EXISTS子查询和IN子查询的时候,会根据小表驱动大表的原则选择适合的子查询。在WHERE子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。举例:查询评论内容开头为abc的内容都有哪些,如果在WHERE子句中使用了函数,语句就会写成下面这样:</p><p>SELECT comment_id, comment_text, comment_time FROM product_comment WHERE SUBSTRING(comment_text, 1,3)=’abc’</p><p>采用查询重写的方式进行等价替换：</p><p>SELECT_comment_id, comment_text, comment_time FROM product_comment WHERE comment_text LIKE abc%</p><h3 id="第四步，优化物理查询"><a href="#第四步，优化物理查询" class="headerlink" title="第四步，优化物理查询"></a>第四步，优化物理查询</h3><p>物理查询优化是在确定了逻辑查询优化之后,采用物理优化技术（比如索引等),通过计算代价模型对各种可能的访问路径进行估算,从而找到执行方式中代价最小的作为执行计划。在这个部分中,我们需要掌握的重点是对索引的创建和使用。但索引不是万能的，我们需要根据实际情况来创建索引。那么都有哪些情况需要考虑呢？我们在前面几章中已经进行了细致的剖析。SQL查询时需要对不同的数据表进行查询,因此在物理查询优化阶段也需要确定这些查询所采用的路径,具体的情况包括：</p><ol><li>单表扫描:对于单表扫描来说,我们可以全表扫描所有的数据,也可以局部扫描。</li><li>两张表的连接:常用的连接方式包括了嵌套循环连接、HASH连接和合并连接。</li><li>多张表的连接:多张数据表进行连接的时候,顺序很重要,因为不同的连接路径查询的效率不同,搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到 很高的数据量级，巨大的搜索空间显然会占用更多的资源,因此我们需要通过调整连接顺序,将搜索空间调整在一个可接受的范围内。</li></ol><h3 id="第五步，使用Redis或Memcached作为缓存"><a href="#第五步，使用Redis或Memcached作为缓存" class="headerlink" title="第五步，使用Redis或Memcached作为缓存"></a>第五步，使用Redis或Memcached作为缓存</h3><p>除了可以对 SQL 本身进行优化以外,我们还可以请外援提升查询的效率。</p><p>因为数据都是存放到数据库中,我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作,当用户量增大的时候,如果频繁地进行数据查询,会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中,就会大幅提升查询的效率。</p><p>键值存储数据库可以帮我们解决这个问题。常用的键值存储数据库有Redis和Memcached,它们都可以将数据存放到内存中。</p><p>从可靠性来说, Redis支持持久化,可以让我们的数据保存在硬盘上,不过这样一来性能消耗也会比较大。而Memcached 仅仅是内存存储，不支持持久化。</p><p>从支持的数据类型来说, Redis比Memcached要多,它不仅支持key-value类型的数据,还支持List, Set, Hash等数据结构。当我们有持久化需求或者是更高级的数据处理需求的时候,就可以使用Redis。如果是简单的keyvalue 存储，则可以使用 Memcached。</p><p>通常我们对于查询响应要求高的场景(响应时间短,吞吐量大) ,可以考虑内存数据库,毕竟术业有专攻。传统的RDBMS都是将数据存储在硬盘上,而内存数据库则存放在内存中,查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p><h3 id="第六步，库级优化"><a href="#第六步，库级优化" class="headerlink" title="第六步，库级优化"></a>第六步，库级优化</h3><p>库级优化是站在数据库的维度上进行的优化策略,比如控制一个库中的数据表数量。另外,单一的数据库总会遇到各种限制,不如取长补短,利用”外援”的方式。通过主从架构优化我们的读写策略,通过对数据库进行垂直或者水平切分,突破单一数据库或数据表的访问限制,提升查询的性能。</p><h4 id="1、读写分离"><a href="#1、读写分离" class="headerlink" title="1、读写分离"></a>1、读写分离</h4><p>如果读和写的业务量都很大,并且它们都在同一个数据库服务器中进行操作,那么数据库的性能就会出现瓶颈,这时为了提升系统的性能,优化用户体验,我们可以采用读写分离的方式降低主数据库的负载,比如用主数据库(master)完成写操作,用从数据库(slave)完成读操作。</p><p>一主一从模式</p><p>双主双从模式</p><h4 id="2-数据分片（按照业务逻辑分散到不同的主机上）"><a href="#2-数据分片（按照业务逻辑分散到不同的主机上）" class="headerlink" title="2.数据分片（按照业务逻辑分散到不同的主机上）"></a>2.数据分片（按照业务逻辑分散到不同的主机上）</h4><p>对数据库分库分表。当数据量级达到千万级以上时,有时候我们需要把一个数据库切成多份,放到不同的数据库服务器上,减少对单一数据库服务器的访问压力。如果你使用的是MySQL,就可以使用MySQL自带的分区表功能,当然你也可以考虑自己做垂直拆分（分库)、水平拆分（分表)、垂直+水平拆分（分库分表)。需要注意的是也会增加维护和使用成本。</p><p>优化MYSQL服务器硬件、MYSQL的参数</p><h3 id="优化数据库结构表"><a href="#优化数据库结构表" class="headerlink" title="优化数据库结构表"></a>优化数据库结构表</h3><p>1.拆分表：冷热数据的分离</p><p>思路:就是将很多字段的表拆分成2个或者多个较小的表，这样做的原因是某些字段操作频率比较高，经常要进行查询或更新操作，而另外一些字段使用频率却很低，冷热数据分离，可以减小表的宽度。</p><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的10。 冷热数据分离的目的是:1.减少磁盘I0,保证热数据的内存缓存命中率。②更有效的利用缓存，避免读入无用的冷数据。</p><p>热数据的主键id和冷数据的id进行连表</p><p>2.增加中间表</p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入中间表中,然后将原来的联合查询改为对中间表的查询,以此来提高查询效率。</p><p>3.增加冗余字段</p><p>4.数据表过多，垂直分库，数据列过多，垂直分表</p><p>垂直拆分的优点:可以使得列数据变小,在查询时减少读取的Block数,减少1/0次数。此外,垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点:主键会出现冗余,需要管理冗余列,并会引起JOIN操作。此外,垂直拆分会让事务变得更加口复杂。</p><p>水平拆分能够支持非常大的数据量存储,应用端改造也少,但分片事务难以解决,跨节点Join性能较差,逻辑复杂。</p><p>《Java工程师修炼之道》的作者推荐尽量不要对数据进行分片,因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构,这样可以减少一次和中间件的网络1/0。下面补充一下数据库分片的两种常见方案：客户端代理:分片逻辑在应用端,封装在jar包中,通过修改或者封装JDBC层来实现。当当网的ShardingJDBC、阿里的TDDL是两种比较常用的实现。中间件代理： 在应用和数据中间加了一个代理层。</p><p>分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat360的Atlas、网易的DDB等等都是这种架构的实现。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><p>原子性（atomicity）：要不全部成功，要么全部失败直接回滚</p><p>一致性（consistency）：操作前后的状态是一致的</p><p>隔离性（isolation）：一个事务的执行不能被其他事务干扰，操作及其使用的数据对并发的其他事务是隔离的，各个事务之间不能互相干扰。</p><p>持久性（durabiltity）：持久到磁盘，持久性通过事务日志来保证的，包括了重做日志和回滚日志。如果我们通过事务对数据的进行修改时，首先会将数据库的变化信息记录到重做日志中，即使数据库崩溃，数据库重启后没有更新到数据库系统中的重做日志，重新执行，从而具有持久性</p><h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>活动的：事务对应的数据库操作，该事务处于活动状态</p><p>部分提交的：没有刷新到磁盘之前，就是处于部分提交的状态</p><p>失败的：活动的、部分提交的遇到错误无法继续执行</p><p>中止的：事务执行了一部分，将已经修改的事物操作还原到事务执行之前的状态，这个状态叫做回滚</p><p>提交的：部分提交的事物将修改过的数据同步到磁盘上</p><h3 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h3><p>我们在autocommit为true的情况下,使用start transaction或begin开启事务,那么DML操作就不会自动提交。</p><p>隐式事务：默认的状态 ,自动提交，对DML操作是有效的，对DDL操作是无效的</p><p>事务的完成过程</p><p>步骤1：开启事务</p><p>步骤2：一系列DML操作（insert，update）</p><p>步骤3：事务的结束状态只有两种：提交的状态COMMIT、中止的状态ROLLBACK</p><p>显式事务</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>某个事物对某个数据进行访问时，其他事务应该排队，当该事务提交之后，其他事务才能继续访问这个数据，但是这样对性能影响比较大，我们既想保住事务的隔离性，又想让同一事物多个事物时性能尽量高些。</p><h3 id="数据并发访问会出现哪些问题？"><a href="#数据并发访问会出现哪些问题？" class="headerlink" title="数据并发访问会出现哪些问题？"></a>数据并发访问会出现哪些问题？</h3><p>1.脏写：一个事务修改了数据并且进行了提交，另一个事务修改数据之后又进行了回滚，数据又回到了原始状态，提交的数据被回滚了，这种现象叫做脏写</p><p>2.脏读：一个事务读到了另外一个事务还未提交的字段，如果另一个事务回滚，第一个事务读到的值就是无效的。</p><p>3.不可重复读：每次读出来的数据不一致，因为被别的事务给更改了，说他有问题他也没有问题</p><p>4.幻读：每次的读取的数据行数不一样，这就意味着发生了幻读，如果删除了这些数据，不能被叫做幻读</p><h3 id="SQL中的四种隔离级别？"><a href="#SQL中的四种隔离级别？" class="headerlink" title="SQL中的四种隔离级别？"></a>SQL中的四种隔离级别？</h3><p>脏写-&gt;脏读-&gt;不可重复读-&gt;幻读</p><p>READ UNCONMITED-&gt;RED CONMITED -&gt;REPEATABLE READ -&gt;SERIALIZABLE，隔离级别越高，数据库的并发性能就越低</p><p>READ UNCONMITED 读未提交，只解决了脏写的问题</p><p>READ CONMITED 读已提交，解决了脏读的问题，只能去读取别人已经提交了的最新的值</p><p>REPEATABLE READ 可重复读，解决了脏读，不可重复读,就算别的事物把值更改了，第二次读的时候值还是跟之前是一样的</p><p>SERIALIZABLE：串行化，解决了脏读，不可重复读，幻读，隐式的添加行锁来解决幻读的问题</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务日志是实现事务四种特性的关键</p><p>事务的隔离性是由锁实现</p><p>事务的原子性，一致性，持久性是由事务的redo日志和undo日志来保证</p><p>redo日志，重做日志，在DML操作之后数据还没有更新到磁盘中，将记录到redo日志中，然后写入磁盘中，如果出现了宕机可以使用重做日志恢复数据来保证持久性</p><p>undo日志，回滚记录到某个特定的版本，保证事务的原子性和一致性</p><p>redo日志，undo日志都是在存储引擎层生成日志，redo日志是物理级别记录磁盘记录，undo日志记录的是逻辑操作，如果进行了一条插入，undo日志记录的是反向删操作，主要是用于事务的回滚逆操作和一致性非锁定读（回滚记录到某种特定的版本—MVCC，多版本并发控制）</p><h4 id="redo日志的好处"><a href="#redo日志的好处" class="headerlink" title="redo日志的好处"></a>redo日志的好处</h4><p>redo日志降低了刷盘频率</p><p>redo日志占用的空间非常小</p><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><p>redo日志是顺序写入磁盘的</p><p>在执行事务的过程中,每执行一条语句,就可能产生若干条redo日志,这些日志是按照产生的顺序写入磁盘的,也就是使用顺序I0，效率比随机10快。</p><p>事务执行过程中，redo log不断记录</p><p>redo log 跟bin log的区别, redo log 是 存储引擎层产生的,而bin log是 数据库层 产生的。假设一个事务,对表做10万行的记录插入,在这个过程中,一直不断的往redo log顺序记录,而bin log不会记录,直到这个事务提交,才会一次写入到bin log文件中。</p><h4 id="redo日志的组成"><a href="#redo日志的组成" class="headerlink" title="redo日志的组成"></a>redo日志的组成</h4><p>Redo日志简单分为两个部分：</p><p>1.重做日志缓冲这个基于内存层面的，一个redo log buffer 占用512字节大小</p><p>2.重做日志文件，保存在磁盘中，具有持久性</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>方案一：读操作利用多版本并发控制MVCC，写操作加锁</p><p>所谓的MVCC ,就是生成一个ReadView,,通过ReadView找到符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读到在生成ReadView之前已提交事务所做的更改,在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而 写操作肯定针对的是 最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写 操作并不冲突。</p><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><p>在READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView, ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改,也就是避免了脏读现象；</p><p>在REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。</p><p>方案二：读写都加锁</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去 读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作,这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录,如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p>不可重复读 的产生是因为当前事务先读取一条记录,另外一个事务对该记录做了改动之后并提交之后,当前事务再次读取时会获得不同的值,如果在当前事务读取记录时就给该记录加锁,那么另一个事务就无法修改该记录,自然也不会发生不可重复读了。</p><p>幻读 问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在,所以读取的时候加锁就有点尴尬(因为你并不知道给谁加锁)。</p><p>总结</p><p>采用 MVCC 方式的话，读-写`操作彼此并不冲突，性能更高。。采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用 MVCC 来解决 读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 加锁的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h3 id="类型划分"><a href="#类型划分" class="headerlink" title="类型划分"></a>类型划分</h3><p>共享锁（Shared Lock, S Lock)和排他锁（Exclusive Lock, XLock)也叫读锁和写锁。</p><p>读锁，针对同一份数据，多个事物读取操作不会互相影响，不会互相阻塞</p><p>写锁，在写操作灭有完成之前，会阻断其他写锁和读锁，只有一个事务能执行写入</p><p>Innodb引擎，读写锁支持表级和行级。</p><h2 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h2><p>MVCC是通过多个版本管理来实现数据库的并发控制，为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样查询就不需要等待另一个事务释放锁。</p><p>快照读：不加锁，非阻塞并发读，指的就是快照读，加锁的操作就是当前读，MVCC是采用一种乐观锁的思想实现的</p><p>实现原理三剑客：隐藏字段、Undo Log、Read View。</p><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>在MVCC机制中,多个事务对同一个行记录进行更新会产生多个历史快照,这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录,需要读取哪个版本的行记录呢?这时就需要用到ReadView了,它帮我们解决了行的可见性问题。</p><p>ReadView 就是事务A在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照, InnoDB为每个事务构造了一个数组,用来记录并维护系统当前活跃事务的ID (“活跃”指的就是,启动了但还没提交）。</p><p>设计思路：</p><p>使用READ UNCOMMITTED隔离级别的事务,由于可以读到未提交事务修改过的记录,所以直接读取记录的最新版本就好了。</p><p>使用SERIALIZABLE隔离级别的事务, InnoDB规定使用加锁的方式来访问记录。</p><p>使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务,都必须保证读到 己经提交了的 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>总结</p><p>核心点在于ReadView的原理, READ COMMITTD, REPEATABLE READ这两个隔离级别的一个很大不同就是生成lReadView的时机不同：READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView</p><p>REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView,之后的查询操作都重复使用这个ReadView就好了。</p><p>说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作,相当于只是对记录打上了一个删除标志位,这主要就是为MVCC服务的。</p><p>通过 MVCC 我们可以解决：</p><p>1.读写之间阻塞的问题。通过MVCC可以让读写互相不阻塞,即读不阻塞写,写不阻塞读,这样就可以提升事务并发处理能力。</p><p>2.降低了死锁的概率。这是因为MVCC采用了乐观锁的方式,读取数据时并不需要加锁,对于写操作,也只锁定必要的行。</p><p>3.解决快照读的问题。当我们查询数据库在某个时间点的快照时,只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p><h2 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h2><p>慢查询日志：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p><p>通用查询日志:记录所有连接的起始时间和终止时间,以及连接发送给数据库服务器的所有指令,对我们复原操作的实际场景、发现问题,甚至是对数据库操作的审计都有很大的帮助。</p><p>错误日志：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题,方便我们了解服务器的状态,从而对服务器进行维护。</p><p>二进制日志(bin log)：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p><p>中继日志:用于主从服务器架构中,从服务器用来存放主服务器二进制日志内容的一个中间文件。</p><p>从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p><p>数据定义语句日志：记录数据定义语句执行的元数据操作。</p><p>除了二进制日志，其他都是文本日志，默认情况下都存放于自己的mysql数据库中的目录中</p><h3 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h3><p>日志功能会降低MySQL数据库的性能。例如,在查询非常频繁的MySQL数据库系统中,如果开启了通用查询日志和慢查询日志, MySQL数据库会花费很多时间记录日志。日志会占用大量的磁盘空间。</p><p>对于用户量非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>日志功能会 降低MySQL数据库的性能。例如,在查询非常频繁的MySQL数据库系统中,如果开启了通用查询日志和慢查询日志, MySQL数据库会花费很多时间记录日志。日志会占用大量的磁盘空间。对于用户量非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</p><p>通常情况下,管理员不需要查看错误日志。但是,MySQL服务器发生异常时,管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p><h3 id="二进制日志（bin-log）"><a href="#二进制日志（bin-log）" class="headerlink" title="二进制日志（bin log）"></a>二进制日志（bin log）</h3><p>binlog即binary log，二进制文件，它主要记录数据库所有执行的DDL和DML等数据库更新事件的语句，不包含查询的语句。</p><p>binlog的主要应用场景：</p><p>一是用于数据恢复，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</p><p>二是用于数据复制，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</p><p>MySQL数据库的数据备份、主备、主主、主从都离不开binlog,需要依靠binlog来同步数据,保证数据一致性</p><p>查看binlog日志命令：mysqlbinlog “/var/lib/mysql/binlog/atguigu-bin.00002”</p><p>show binlog events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];</p><p>binlog与redolog对比</p><p>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</p><p>而 binlog 是 逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQLServer 层。</p><p>虽然它们都属于持久化的保证，但是则重点不同。</p><p>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</p><p> binlog保证了MySQL集群架构的数据一致性。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机 不一样。</p><p>为了解决两份日志之间的逻辑一致问题, InnoDB存储引擎使用两阶段提交方案。原理很简单,将redo log的写入拆成了两个步骤prepare和commit,这就是两阶段提交。</p><h3 id="中继日志Realy-log"><a href="#中继日志Realy-log" class="headerlink" title="中继日志Realy log"></a>中继日志Realy log</h3><p>将主服务的binlog日志读到从服务器，然后将二进制文件存储为Realy log。</p><p>中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致,要从主服务器读取二进制日志的内容,并且把读取到的信息写入本地的日志文件中,这个从服务器本地的日志文件就叫 中继日志。然后,从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p><p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p><p>文件名的格式是： 从服务器名 -relay-bin.序号。中继日志还有一个索引文件： 从服务器名 -relaybin.index，用来定位当前正在使用的中继日志。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一般对于数据库而言都是读多写少，对数据库的访问压力比较大，思路就是采用集群的方案做主从架构，进行读写分离，这样可以提高数据库的并发能力。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 优化SQL和索引，这种方式简单有效;其次才是采用缓存的策略,比如使用Redis将热点数据保存在内存数据库中,提升读取的效率;最后才是对数据库采用 主从架构，进行读写分离。按照上面的方式进行优化,使用和维护的成本是由低到高的。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.读写分离，我们可以通过主从复制的方式来 同步数据，然后通过读写分离提高数据库并发处理能力。</p><p>其中一个是Master主库，负责写入数据，我们称之为：写库。</p><p> 其它都是Slave从库，负责读取数据，我们称之为：读库。</p><p>其中一个是Master主库，负责写入数据，我们称之为：写库。其它都是Slave从库，负责读取数据，我们称之为：读库。</p><p>面对“读多写少”的需求,采用读写分离的方式,可以实现更高的并发访问。同时,我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让 读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响,比如我们让主库负责写,当主库出现写锁的时候,不会影响到从库进行SELECT的读取。</p><p>2.数据备份</p><p>我们通过主从复制将主库上的数据复制到了从库上,相当于是一种热备份机制,也就是在主库正常运行的情况下进行的备份,不会影响到服务。</p><p>3.高可用性。</p><p>数据备份实际上是一种冗余的机制,通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现 故障 或 宕机 的情况下，可以 切换 到从服务器上，保证服务的正常运行。关于高可用性的程度,我们可以用一个指标衡量,即正常可用时间/全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过 365<em>24</em>60* （1-99.999%） =5.256 分钟（含系统崩溃的时间、日常维护操作导致的停机时间等),其他时间都需要保持可用的状态。实际上,更高的高可用性,意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中,会基于3个线程来操作,一个主库线程，两个从库线程。</p><p>二进制日志转储线程（Binlog dump thread）是一个主库线程。当从库线程连接的时候，主库可以将二进制日志发送给从库,当主库读取事件(Event)的时候,会在Binlog上加锁,读取完成之后,再将锁释放掉。</p><p>从库1/0线程会连接到主库,向主库发送请求更新Binlog。这时从库的1/0线程就可以读取到主库的二进制日志转储线程发送的Binlog更新部分,并且拷贝到本地的中继日志(Relay log) 。</p><p>从库 SQL 线程会读取从库中的中继日志,并且执行日志中的事件,将从库中的数据与主库保持同步。</p><p>复制三步骤步骤</p><p>1: Master 将写操作记录到二进制日志（binlog)。这些记录叫做二进制日志事件(binary log events);</p><p>步骤2: Slave将Master 的binary log events拷贝到它的中继日志(relay log) ;</p><p>步骤3: Slave重做中继日志中的事件,将改变应用到自己的数据库中。MySQL复制是异步的且串行化的,而且重启后从 接入点 开始复制。</p><p>最大的问题就是：超时</p><p>复制的基本原则</p><p>每个Slave 只有一个 Master</p><p>每个 Slave 只能有一个唯一的服务器ID</p><p>每个Master 可以有多个 Slave</p><h3 id="同步数据一致性问题"><a href="#同步数据一致性问题" class="headerlink" title="同步数据一致性问题"></a>同步数据一致性问题</h3><p>主从同步的要求：</p><p>读库和写库的数据一致(最终一致)；</p><p>写数据必须写到写库；</p><p>读数据必须到读库(不一定)；</p><p>异步复制</p><p>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果,而是直接将结果返回给客户端,这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而 Binlog 还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主,那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><p>半同步复制</p><p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端,而是等待至少有一个从库接收到了Binlog,并且写入到中继日志中,再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p>组复制</p><p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端,而是等待至少有一个从库接收到了Binlog,并且写入到中继日志中,再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数,可以对应答的从库数量进行设置,默认为1,也就是说只要有1个从库进行了响应,就可以返回给客户端。如果将这个参数调大,可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。</p><h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p>在任何数据库环境中,总会有不确定的意外情况发生,比如例外的停电、计算机系统中的各种软硬件故障、人为破坏、管理员误操作等是不可避免的,这些情况可能会导致数据的丢失、服务器瘫痪等严重的后果。存在多个服务器时，会出现主从服务器之间的 数据同步问题。为了有效防止数据丢失,并将损失降到最低,应定期对MySQL数据库服务器做备份。</p><p>如果数据库中的数据丢失或者出现错误，可以使用备份的数据 进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。</p><h3 id="物理备份与逻辑备份"><a href="#物理备份与逻辑备份" class="headerlink" title="物理备份与逻辑备份"></a>物理备份与逻辑备份</h3><p>物理备份:备份数据文件,转储数据库物理文件到某一目录。物理备份恢复速度比较快,但占用空间比较大,MySQL中可以用xtrabackup工具来进行物理备份。</p><p>逻辑备份:对数据库对象利用工具进行导出工作,汇总入备份文件内。逻辑备份恢复速度慢,但占用空间小,更灵活。MySQL中常用的逻辑备份工具为mysqldump。逻辑备份就是备份sql语句,在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>物理备份:备份数据文件,转储数据库物理文件到某一目录。物理备份恢复速度比较快,但占用空间比较大,MySQL中可以用xtrabackup工具来进行物理备份。</p><p>逻辑备份:对数据库对象利用工具进行导出工作,汇总入备份文件内。</p><p>逻辑备份恢复速度慢,但占用空间小,更灵活。MySQL中常用的逻辑备份工具为mysqldump。</p><p>逻辑备份就是备份sql语句,在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程JUC</title>
      <link href="/2023/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8BJUC/"/>
      <url>/2023/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8BJUC/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>程序是由指令和数据组成，指令要执行需要加载到CPU，数据要读写要加载到内存中。</p><p>进程就是用来加载指令、管理内存、管理IO的，当一个程序被运行，从磁盘加载这个程序的代码，这个时候就开启了 一个进程，进程可以看做一个程序。</p><p>例如记事本、浏览器可以同时开启多个实例进程，网易云、360卫士只能开启一个实例进程。</p><p>一个进程中可以分为一到多个线程，每一个线程就是一个指令流，将指令流里的一条条指令交给CPU去执行</p><p>在Java中，线程是最小调度单位，进程作为资源分配的最小单位。</p><h1 id="并发Concurrent与并行parallel"><a href="#并发Concurrent与并行parallel" class="headerlink" title="并发Concurrent与并行parallel"></a>并发Concurrent与并行parallel</h1><p>并发Concurrent是同一时间应对多件事情的能力</p><p>单核cpu下将cpu的时间片交给不同的线程使用，由于线程间的时间片非常短切换很快，一般这种线程轮流使用CPU的做法成为并发</p><p>并行parallel是同一时间动手执行一件事情</p><p>多核cpu下，每个核都可以调度运行线程，这个时候线程就是并行的</p><p>结论:1.在单核cpu下并不能提升运行效率，而是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活。</p><p>​         2.多核cpu可以并行跑多个线程，但是否提升运行效率还需要具体看情况，有些任务经过精心设计，将任务拆分，并行执行，可以提高程序的效率。</p><p>​        3.IO操作不占用CPU，只是我们一般拷贝文件使用的是阻塞IO，这时相当于线程虽然不要cpu，但是需要一直等待IO结束，没能充分利用线程，后面才有的非        阻塞IO和异步IO优化。</p><h1 id="同步-异步调用"><a href="#同步-异步调用" class="headerlink" title="同步/异步调用"></a>同步/异步调用</h1><p>如果一个方法需要等待结果返回，才能继续运行就是同步。</p><p>如果一个方法无需等待结果返回，就可以继续运行就是异步。</p><h1 id="创建多线程方法"><a href="#创建多线程方法" class="headerlink" title="创建多线程方法"></a>创建多线程方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Thread01&quot;)</span><br><span class="line">public class Thread01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                log.debug(&quot;running&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        log.debug(&quot;running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">二、实现Runnable接口重写run方法</span><br><span class="line">@Slf4j(topic = &quot;c.Thread02&quot;)</span><br><span class="line">public class Thread02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                log.debug(&quot;running&quot;);</span><br><span class="line">                System.out.println(&quot;running&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = new Thread(runnable,&quot;t2&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        log.debug(&quot;running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  lambda简化</span><br><span class="line">  Runnable runnable =() -&gt; &#123;</span><br><span class="line">           log.debug(&quot;running&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  Thread thread = new Thread(runnable,&quot;t2&quot;);</span><br><span class="line">  thread.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">三、实现Callable接口重写call方法，利用FuturnTask实现类的get获取返回值</span><br><span class="line">@Slf4j(topic = &quot;c.Thread03&quot;)</span><br><span class="line">public class Thread01&#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                log.debug(&quot;running&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread = new Thread(futureTask,&quot;t3&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        log.debug(&quot;&#123;&#125;&quot;,futureTask.get());//阻塞一直等待结果的返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、继承Thread类重写run方法</p><p>二、实现Runnable接口重写run方法</p><p>三、实现Callable接口重写call方法，利用FuturnTask实现类的get获取返回值</p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>非守护线程（main主方法）执行完毕，守护线程也会结束</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>start：进入到就绪状态。</p><p>sleep：线程的睡眠时间，可以让线程让出时间片。</p><p>yield：让出当前线程的时间片。</p><p>join：同步等待当前线程执行完后，之后才会让出当前线程时间片，让其他线程去执行。</p><p>interrup：线程的打断会抛出异常</p><p>必须获得此对象的锁，才能调取以下的方法</p><p>obj.wiat()让进入object监视器的线程到wait等待，无限制等待，可以加参数限制等待的时间</p><p>obj.notify 在object上正在waitSet等待的线程中挑一个唤醒</p><p>obj.notifyAll 让object上正在waitSet等待的线程全部唤醒</p><p>sleep在加锁 睡眠的同时不会释放锁，wait在等待的时候会释放对象锁</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>操作系统层面：5种状态</p><p>初始状态：创建线程，并且调用start方法</p><p>可运行状态：（就绪状态）：在执行了start方法之后，线程进入就绪状态，等待cpu的调度执行</p><p>运行状态：是指当前线程在运行中，获得cpu时间片（将运行状态转至就绪状态，会导致线程的上下文切换）</p><p>阻塞状态：如果调用了BIO阻塞API读取文件，这时候不会用到cpu，会导致上下文切换，进入阻塞状态</p><p>​                    等BIO执行操作完毕后，线程进入就绪状态，等待cpu的调度</p><p>终止状态：表示线程已经执行完毕，生命周期结束，不会再转换为其他状态</p><p>基于JAVA api层面有6种状态</p><p>NEW:创建线程对象，还没有调用start方法</p><p>Runnable ：一直在运行中</p><p>TERNINATED：线程运行结束，整个线程执行完了</p><p>TIME_WAITING:有时间的等待 sleep</p><p>WAITING：join一直在等待状态</p><p>BLOCKED：想获得锁被阻塞了</p><h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>临界区：在多线程访问的时候发生了竞争条件（在读写的时候，当第一个线程读到还没有写出去就发生了时间片的切换，另外一个线程进行了读写之后，第一个线程继续进行写，这里就产生的线程安全问题）</p><p>如何避免临界区的竞态条件发生？</p><p>阻塞：synchronized、Lock</p><p>非阻塞:原子变量</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized俗称对象锁，使用互斥的方式让同一时刻只能有一个线程持有对象锁，其他获取这个对象锁就会阻塞，这样可以保证安全的执行临界区的代码，不用担心上下文的切换。</p><p>如果当前线程临界区上了对象锁，在代码还没有执行完的时候，发生了时间片的切换，后边的线程会进行一个阻塞等待，并且一直等待当前线程执行完才能进行释放锁。</p><p>synchronized是用对象锁保证了临界区代码的原子性，要想保护共享资源就要保证锁的是同一个对象</p><p>考虑代码块的原子性，线程共享的对象都要进行上锁</p><p>synchronized（this）{} 等价于 public void synchronized method（）{}都是锁住了当前对象</p><p>如果将synchronized加到静态方法上就是锁住了当前类</p><h2 id="synchronized轻量级锁001"><a href="#synchronized轻量级锁001" class="headerlink" title="synchronized轻量级锁001"></a>synchronized轻量级锁001</h2><p>（1）加了synchronized之后，方法创建在栈帧，每个栈帧中包含一个锁记录（Lcok Record）对象，内部存储锁定Mark Word</p><p>（2）让锁记录的Object Reference指向锁对象，并尝试使用cas替换对象Object的Mark Word，将Mark Word的值存入锁记录</p><p>（3）如果cas替换成功，对象头中存储锁记录地址和状态00</p><p>​        如果替换失败有两种情况：（1）如果是其他线程持有了当前对象的轻量级锁，说明锁有竞争，进入锁膨胀时期。</p><p>​                                                        （2）如果当前线程自己又执行上锁，就会添加一条Lock Record作为重入的计数，这就是重入锁，当前方法执行完之后计数减一。</p><h2 id="synchronized锁膨胀"><a href="#synchronized锁膨胀" class="headerlink" title="synchronized锁膨胀"></a>synchronized锁膨胀</h2><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，表明其他线程给对象加了轻量级锁，需要进行锁膨胀，将轻量级锁变为重量级。</p><p>Thread-0已经对该对象加了轻量级锁，Thread1又要进行加轻量级锁时就会失败，就会为当前的对象申请Monitor锁，让对象指向重量级锁地址，然后Thread-1（自旋竞争锁）进入M onitor的EntryList Blocked阻塞队列。</p><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头会失败。这时会进入重量级解锁流程，即Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中的Blocked线程。</p><h2 id="synchronized偏向锁101"><a href="#synchronized偏向锁101" class="headerlink" title="synchronized偏向锁101"></a>synchronized偏向锁101</h2><p>用ThreadID替换Markword</p><p>轻量级锁在没有竞争的情况下（当前线程），每次重入锁都需要执行CAS操作。</p><p>在java 6中引入了偏向锁来进一步优化：第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。</p><p>对象创建的时候，如果开启了偏向锁（默认开启）：偏向锁时默认延迟的，不会在程序启动的时候立即生效 ，如果想避免延迟，需要加jvm参数。markword值为最后三位101，这时thread、epoch、age都为0</p><p>如果没有开启偏向锁，创建对象后，markword值为最后三位001，这时hashcode、age都为0，第一次用到hashcode才会赋值（调用hashcode会禁用这个对象的偏向锁，转换为轻量级锁）</p><p>撤销偏向锁的两种方式</p><p>（1）调用对象的hashcode，但是偏向锁的对象markword中存储的是线程id，调用hashcode会导致偏向锁撤销</p><p>轻量级锁会在锁记录中记录hashCode，重量级锁会在Monitor中记录hashCode</p><p>（2）其他线程使用偏向锁对象时，偏向锁就会升级为轻量级锁。</p><p>一个线程加锁是偏向锁，多个线程加锁是轻量级锁，然后是锁膨胀为重量级锁</p><p>批量重偏向</p><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID，当偏向锁阈值超过20次后，会给这些对象加锁时重新偏向至加锁线程</p><p>批量撤销</p><p>当撤销偏向锁阈值超过40次所有的对象都会变为不可偏向的，新建对象也是不可偏向的。</p><p>锁消除优化</p><h1 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h1><p>成员变量、静态变量：没有被共享则线程安全，如果被共享根据状态来分辨是不是线程安全，如果是读操作，则线程安全。如果是读写操作，这段代码是临界区，需要考虑线程安全</p><p>局部变量是线程安全的，但是局部变量引用的对象则有可能不是线程安全，如果没有逃离方法的作用方法，是线程安全，如果该对象逃离方法的作用范围，需要考虑线程安全</p><p>多线程组合调用安全的方法也会发生线程安全问题</p><h1 id="Monitor（锁）概念"><a href="#Monitor（锁）概念" class="headerlink" title="Monitor（锁）概念"></a>Monitor（锁）概念</h1><p>Monitor又叫监视器或管程 </p><p>刚开始Monitor中Owner（moinitoe所有者）为null</p><p>当线程1执行synchronized（obj）就会将Monitor的所有者Owner设置为线程1，Monitor中只能有一个Owner</p><p>在线程1上锁的过程中，如果线程2、3也来执行synchronized（obj），就会进入EntryList Blocked阻塞</p><p>线程1执行完同步代码块的内容，然后唤醒EntryList中等待线程来竞争锁，竞争是非公平的（随机竞争不会按照顺序）</p><p>WaitSet：调用了wait方法，执行notify就会唤醒waitSet队列的线程，</p><p>原理：Ower发展条件不满足的时候，调用wait方法，即可进入WaitSet变为Waiting状态</p><p>​            Waiting线程会在Owner线程调用notify或notifyAlll时唤醒，但唤醒不意味立刻获得锁，仍需要进入EntryList重新竞争</p><p>synchronized必须进入同一个对象的monitor才会有上述的效果，不加synchronized的对象不会关联监视器</p><h1 id="Park和Unpark"><a href="#Park和Unpark" class="headerlink" title="Park和Unpark"></a>Park和Unpark</h1><p>LockSupport.park() 暂停当前线程</p><p>LockSupport.unpark（）暂停线程对象</p><h2 id="死锁和活锁"><a href="#死锁和活锁" class="headerlink" title="死锁和活锁"></a>死锁和活锁</h2><p>死锁：两个线程互相持有对方想要的锁，导致程序无法执行</p><p>活锁：两个线程改变了对方的结束条件，两个线程在不断的运行结束不了<br>饥饿：表示有的线程永远拿不到锁</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>与synchronized的区别</p><p>可中断（可以破坏锁，中断）调用lockInterruptibly方法加锁</p><p>可以设置超时时间（规定时间内获取不到锁就放弃执行）</p><p>可以设置为公平锁（防止线程饥饿的情况，先进先出）</p><p>支持多个变量（多个wiatSet队列等待）</p><p>都可以重入</p><p>lockInterruptibly方法加锁：lock锁如果没有竞争就会获取到lock对象锁，如果有竞争就进入阻塞队列，可以被其他线程打断</p><p>tryLock ：尝试获取锁，返回布尔值，返回true获得到了锁，返回false没有获得到锁，防止无限制的等待，防止死锁</p><p>Condition条件变量</p><p>await（）前需要获得到锁，</p><p>执行之后会释放锁，进入conditionObject等待（调用newCondition进入wiatSet队列）</p><p>await的线程被唤醒（打断或超时）重新竞争lock锁</p><p>竞争lock锁成功后，从await后继续执行</p><h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><p>公平锁和非公平锁</p><h3 id="加锁成功"><a href="#加锁成功" class="headerlink" title="加锁成功"></a>加锁成功</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1)) //加锁成功</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.没有竞争的情况下，将state改为1，并且将ExclusiveOwnerThread设置为当前线程。</p><p>2.如果出现的竞争，走acquire(1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS尝试将state由0改为1，仍然失败</p><p>进入tryAcquire逻辑，state已经是1，结果仍然失败</p><p>接下来进入addWaiter逻辑构造Node队列，其中第一个是Dummy哑元或哨兵，用来占位不关联线程。</p><p>然后进入acquireQueued</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued会在一个死循环中不断尝试获得锁，失败进入park阻塞</p><p>如果自己是紧邻着head（排第二位），那么再次tryAcquire尝试获取锁，当state为1，失败</p><p>进入shouldParkAfterFailedAcquire逻辑，将前驱node，即head的wiatStatus改为-1，再次返回false</p><p>shouldParkAfterFailedAcquire执行完毕回到acquireQueued，再次tryAcquire尝试获得锁，当然这时state仍为1失败</p><p>当再次进入shouldParkAfterFailedAcquire时，这时因为前驱node的waitStatus已经是-1，这次返回true</p><p>进入parkAndCheckInterrupt，Thread-Park</p><p>锁竞争成功之后 释放锁</p><p>设置setExclusiveOwnerThread为null，state=0</p><p>当队列不为null时，并且head的wiatStutes=-1，进入unparkSuccessor流程</p><p>找到队列中离head最近的一个Node，unpark恢复运行，回到线程acquireQueued运行流程</p><p>如果不巧被其他线程又占用，获取锁失败，还得重新进入park阻塞</p><h2 id="锁重入原理"><a href="#锁重入原理" class="headerlink" title="锁重入原理"></a>锁重入原理</h2><p>如果已经获得了锁，线程还是当前线程， 表示发生了锁重入，只有state减为0，才能释放成功</p><h2 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h2><p>需要获得锁才能够打断，如果被打断则设置intrrupted为true</p><h2 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h2><p>非公平锁：尝试cas获得，不去检查AQS队列就去检查锁了</p><p>公平锁:检查AQS队列中是否有前置区节点，没有才去竞争</p><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p>JMM即Java Memory Moder，定义了主存（所有线程都共享的数据），工作内存（每个线程私有的）</p><p>JMM主要体现在以下几个方面：原子性-保证指令不会受到线程上下文切换的影响</p><p>​                                                    可见性-保证指令不会受cpu缓存的影响</p><p>​                                                    有序性-保证指令不会受cpu指令并行优化的影响</p><p> 一个线程对主存的修改，对于另外一个线程不可见，读取的永远是旧值，就出现了问题。（因为另外一个线程频繁从主内存中读取run的值，JIT编译器会将值缓存在自己工作内存中高速缓存区，减少对主存的访问，提高效率）</p><p>解决：使用volatile关键字，就不会从缓存中取值了。volatile不能保证原子性，只能保证可见性</p><p>可见性：保证在多个线程之间，一个线程对volatile变量修改对另一个线程可见，不能保证原子性，用在一个写线程，多个读线程。</p><p>有序性：如何保证有序性？写屏障会确保指令重排时，不会将屏障之前的代码排在写屏障之后，读屏障会保证在指令重排序时，不会将读屏障之后的代码排在读屏障之前。</p><p>如何保证可见性？</p><p>写屏障（sfence)保证在该屏障之前，对共享变量的改动，都同步到主存中。</p><p>读屏障（Ifence）保证在该屏障之后，对共享变量的读取，加载的是主存中的最新数据</p><p>原理？</p><h1 id="无锁并发CAS与volatile"><a href="#无锁并发CAS与volatile" class="headerlink" title="无锁并发CAS与volatile"></a>无锁并发CAS与volatile</h1><h2 id="CAS的工作-方式"><a href="#CAS的工作-方式" class="headerlink" title="CAS的工作 方式"></a>CAS的工作 方式</h2><p>CAS比较并交换，底层使用lock cmpxchg指令，在单核和多核都可以保证比较交换的原子性 </p><p>如果共享变量的值和当前读到的值相同，则成功，如果值不同则失败</p><p> CAS需要借助volati0le才能读取到共享变量的最新值，实现比较并交换</p><p>CAS是乐观锁（无锁），不怕别人来修改共享变量，改了就去失败重试，无阻塞并发，无锁并发，如果竞争激烈，重试比较频繁发生，效率也会受到影响</p><p>syn是悲观锁，防止其他线程来修改变量，别的线程来了要阻塞</p><p>适用于线程数少、多核cpu的场景下</p><p>原子整数</p><p>AtomicInteger</p><p>-get：获取最新值</p><p>-compareAndSet：比较并设置</p><p>原子引用：AtomicReference</p><p>ABA问题：共享变量在更改之后，又被改了回去，仅仅只能判断出值是否与最初的值是否相同，不能感知到被改又改回去的情况。</p><p>AtomicStampedReference加版本号的实现</p><p>AtomicMarkableReference关心这个变量有没有被更改过</p><p>原子数组：AtomicIntegerArray 数组整形，AtomicLongArray 数组长整形，AtomicReferenceArray 数组引用</p><p>原子更新：AtomicRefenceFieldUpdater </p><p>原子累加器</p><p>LongAddr：在有竞争的情况下，设置多个累加单元，这样他们在累加的时候在操作不同的cell变量，减少了cas重试次数，从而提高了性能</p><p>transient volatile Cell[] cells; 累加单元组，懒惰初始化</p><p>transient volatile long base 累加单元域</p><p>transient volatile int cellsBusy 创建或扩容时，置为1，表示加锁</p><p>@Contended 防止缓存行伪共享</p><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>提供非常底层的，操作内存，线程的方法，Unsafe 只能通过反射获得，不能直接调用。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>定义：重用之前创建好的对象</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>构造方法ThreadPoolExecutor</p><p>corePoolSize 核心线程数（最多保留的线程数）</p><p>maximumPoolSize 最大线程数（救急线程，阻塞队列放不下会使用）</p><p>keepAliveTime 生存时间 -针对救急线程</p><p>unit 时间单位 -针对救急线程</p><p>workQueue 阻塞队列</p><p>threadFactory 线程工厂 -可以为线程创建时起名字</p><p>handler 拒绝策略（救急线程如果满了，会使用拒绝策略）</p><p>救急线程配合有界队列来使用</p><p>jdk提供了4种拒绝策略</p><p>1.AbortPolicy 让调用者抛出RejectedException异常，这是默认策略</p><p>2.CallerRunsPolicy 让调用者运行任务</p><p>3.DiscardPolicy 放弃本次任务</p><p>4.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p><p>Exectors工具类</p><p>newFixedThreadPool：核心线程数=急救线程数，没有救急线程被创建，因此没有超时时间，队列无界，可以放任意数量的任务</p><p>newCacheThreadPool：核心线程是0，最大线程是Interger.MAX_VALUE，救急线程的空闲生存时间是60s，意味着全部都是救急线程60s后可以回收，救急线程可以无限创建</p><p>队列采用了SynchronousQueue：他没有容量，没有线程来取，是放不进去的。</p><p>newSingleThreadExector:单线程线程池，线程数固定为1，任务书多于1时，会放入无界队列，任务执行完毕，这唯一的线程也不会释放</p><h1 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h1><p>Timer类：串行执行，同一时间只能有一个任务在执行，前一个任务的延迟或异常都会影响之后的任务</p><p>ScheduledExectorService</p><h1 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h1><p>全称是AbstractQueuedSynchronizer，阻塞式锁</p><p>state：表示资源的状态（独占模式：只有一个线程能访问资源、共享模式：允许多个线程访问资源）</p><p>getState - 获取state状态</p><p>setState - 设置state状态</p><p>compareAndSetState - cas机制设置state状态</p><p>提供了FIFO的等待队列，类似于Monitor的EntryList</p><p>条件变量实现等待、唤醒机制、支持多个条件变量，类似于Monitor的WaitSet</p><h1 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h1><p>用来进行线程同步协作，等待所有线程完成倒计时</p><p>构造函数用来初始化等待计数值，await用来等待计数归零才会结束，countDown用来计数减一</p><p>使用场景：异步编排</p><h1 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h1><p>循环栅栏，等待线程满足某个计数，构造时设置计数个数，每个线程执行到某个需要同步的时刻调用wait方法进行等待，但等待的线程数满足计数个数继续执行。</p><h1 id="并发类"><a href="#并发类" class="headerlink" title="并发类"></a>并发类</h1><p>Blocking大部分实现基于锁，并提供用来阻塞的方法</p><p>CopyOnWrite 读多写少，容器修改的开销相对较重</p><p>Concurrent类型的容器：内部使用cas优化提供较高吞吐量，遍历时如果发生了修改，对于非安全容器来讲，会使用fail-fast机制让遍历立即失败，抛出ConcurrentModificationExection，不再继续遍历，</p><p>弱一致性：利用迭代器遍历时，如果容器发生改变，迭代器仍然可以继续遍历，这时内容是旧的。</p><p>读取弱一致性</p><p>size操作未必是准确的</p><h1 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h1><p>hashmap jdk7 put头插法，在多线程环境下会出现死链，jdk8虽然对扩容算法做了调整，不再将元素加入链表头，不意味着在多线程环境下能够安全扩容，还会出现其他问题（如扩容丢数据）</p><p>第一个线程重新hash分布  哈希桶1  35-&gt;1-&gt;null</p><p>第二个线程 哈希桶1  35-&gt;1-&gt;null ，继续扩容，发现35的下个节点是1继续插入，形成死链</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/09/10/SpringBoot/"/>
      <url>/2023/09/10/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么导入dependency时不需要指定版本？"><a href="#为什么导入dependency时不需要指定版本？" class="headerlink" title="为什么导入dependency时不需要指定版本？"></a>为什么导入dependency时不需要指定版本？</h1><p>spring-boot-starter-parent通过继承spring-boot-dependencies从而实现了SpringBoot的版本依赖管理所以我们的SpringBoot工程继承spring-boot-lstarter-parent后已经具备版本锁定等配置了,这也就是在 Spring Boot 项目中部分依赖不需要写版本号的原因</p><h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><p>根据我们添加的jar包依赖，会自动将一些配置类的bean注册到ioc容器中，需要的地方使用@autowried或者@resource等注解来使用。</p><h1 id="Spring是如何进行自动配置的？"><a href="#Spring是如何进行自动配置的？" class="headerlink" title="Spring是如何进行自动配置的？"></a>Spring是如何进行自动配置的？</h1><p>启动一个被@springbootApplication注解标注的主配置类的main方法来进行自动配置。</p><h1 id="注解的原理解释？"><a href="#注解的原理解释？" class="headerlink" title="注解的原理解释？"></a>注解的原理解释？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication：组合注解</span><br></pre></td></tr></table></figure><p>Springboot中有很多以Enable开头的注解，作用就是借助@Import来收集并且注册特定场景相关的bean，并且加载到ioc容器，@EnableAutoConfiguration就是这样做的</p><h2 id="EnableAutoConfiguration-分析"><a href="#EnableAutoConfiguration-分析" class="headerlink" title="@EnableAutoConfiguration 分析"></a>@EnableAutoConfiguration 分析</h2><p>主要组合的注解有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br></pre></td></tr></table></figure><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>里边包含了@Import(AutoConfigurationPackages.Registrar.class)</p><p>AutoConfigurationPackages.Registrar这个类就干一个事，注册一个Bean，这个Bean 就是</p><p>org.springframework.boot.autoconfigure.AutoConfigurationPackages.BasePackages，</p><p>它有一个参数，这个参数是使用了@AutoConfigurationPackage这个注解的类所在的包路径，保存自动配置类以供之后的使用</p><h2 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h2><p>1.先走这个process方法，读取一些符合规则的自动配置类</p><p>2.调用selectImports</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">   for (DeferredImportSelectorHolder deferredImport : this.deferredImports) &#123;</span><br><span class="line">      this.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">            deferredImport.getImportSelector());</span><br><span class="line">   &#125;</span><br><span class="line">   return this.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结springboot自动配置的原理</p><p>1.从spring.factories配置文件中加载自动配置类；</p><p>2.加载的自动配置类中排除掉@EnableAutoConfiguration注解的exclude属性指定的自动配置类:</p><p>3.然后再用AutoConfigurationImportFilter接口去过滤自动配置类是否符合其标注注解(若有标注的话)</p><p>@Conditionalonclass,@ConditionalonBean 和@ConditionalonwebApplication的条件，若都符合的话则返回匹配结果</p><p>4,然后触发AutoConfigurationImportEvent事件,告诉ConditionEvaluationReport条件评估报告器对象来分别记录符合条件和exclude的自动配置l类。</p><h1 id="谈谈你对springboot的理解？它有哪些优点？"><a href="#谈谈你对springboot的理解？它有哪些优点？" class="headerlink" title="谈谈你对springboot的理解？它有哪些优点？"></a>谈谈你对springboot的理解？它有哪些优点？</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>springboot是spring框架开发的一个脚手架，用来简化spring应用的初始搭建过程。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以使用springboot提供的内置starter进行自动配置，对于主流的框架无需配置，开箱即用</p><p>采用javaconfig的方式零xml的方式进行开发</p><p>内置web容器无需依赖外部web服务器，直接运行jar可以启动应用</p><p>管理了第三方依赖的版本，减少出现版本冲突的问题</p><p>自带了监控，内存，线程池，http请求统计的功能</p><h1 id="spring和springboot的关系的和区别？"><a href="#spring和springboot的关系的和区别？" class="headerlink" title="spring和springboot的关系的和区别？"></a>spring和springboot的关系的和区别？</h1><p>都是生态产品</p><p>spring Framework是一个容器框架</p><p>boot是一个可以快速构建spring的脚手架</p><h1 id="springboot的核心注解？"><a href="#springboot的核心注解？" class="headerlink" title="springboot的核心注解？"></a>springboot的核心注解？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication：组合注解，标识为当前项目是一个springboot工程</span><br><span class="line">@SpringBootConfiguration：实际上就是一个@Configuration，表示启动类也是一个配置类</span><br><span class="line">@EnableAutoConfiguration ：向spring容器中导入一个selector，用来加载classpath下的springFactories中所定义的自动配置类，自动加载为Bean</span><br><span class="line">@Conditional：满足设定的条件，将bean注册到spring容器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="springboot的自动配置原理？"><a href="#springboot的自动配置原理？" class="headerlink" title="springboot的自动配置原理？"></a>springboot的自动配置原理？</h1><p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个 注解是对三个注解进行了封装，分别是：</p><p> @SpringBootConfiguration</p><p> @EnableAutoConfiguration</p><p> @ComponentScan</p><p>其中 @EnableAutoConfiguration 是实现自动化配置的核心注解。 该注解通过 @Import 注解导入对应的配置选择器。关键的是内部就是读取了 该项目和该项目引用的Jar包的的classpath路径下METAINF/spring.factories文件中的所配置的类的全类名。</p><p>在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要 将其导入到Spring容器中。 一般条件判断会有像 @ConditionalOnClass 这样的注解，判断是否有对应的 class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器 中使用。</p><h1 id="为什么springboot的jar可以直接运行？"><a href="#为什么springboot的jar可以直接运行？" class="headerlink" title="为什么springboot的jar可以直接运行？"></a>为什么springboot的jar可以直接运行？</h1><p>1.SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。</p><p>2.Spring Boot应用打包之后,生成一个Fat jar(jar包中包含jar),包含了应用依赖的jar包和Spring Boot loader相关的类。</p><p>3.java-jar会去找jar中的manifest文件，在那里面找到真正的启动类（Main-Class）</p><p>4.Fat jar的启动Main函数是JarLauncher，它负责创建一个LaunchedURLClassLoader来加载boot-lib下面的jar，并以一个新线程启动应用的启动类的Main函数（找到manifest中的Start-Class）。</p><h1 id="springboot的启动原理"><a href="#springboot的启动原理" class="headerlink" title="springboot的启动原理"></a>springboot的启动原理</h1><p>1.运行main方法，初始化Application。 从spring.factories读取listener（ApplicationContextInitializer）</p><p>2.运行run方法</p><p>3.读取环境变量，配置信息</p><p>4.创建springApplication上下文：ServletWebServerApplicationContext</p><p>5.初始化上下文：读取启动类-&gt;BeanDefinition</p><p>6.调用refresh加载ioc容器</p><p>invokeBeanFactoryPostProcessor加载所有的自动配置类–解析Import加载所有的自动配置类</p><p>onRefresh 创建(内置)servlet容器</p><p>7.在这个过程中springboot会调用很多监听器对外进行扩展</p><h1 id="springboot内置tomcat原理？"><a href="#springboot内置tomcat原理？" class="headerlink" title="springboot内置tomcat原理？"></a>springboot内置tomcat原理？</h1><p>当依赖Spring-boot-starter-web依赖时会在SpringBoot中添加: ServletWebServerFactoryAutoConfiguration </p><p>servlet容器自动配置类该自动配置类通过@lmport导入了可用(通过@ConditionalOnClass判断决定使用哪一个)的一个Web容器工厂(默认Tomcat)</p><p>在内嵌Tomcat类中配置了一个TomcatServletWebServerFactory的Bean (Web容器工厂）</p><p>它会在SpringBoot启动时加载ioc容器(refresh) OnRefersh创建内嵌的Tomcat并启动</p><h1 id="springboot外部tomcat原理？"><a href="#springboot外部tomcat原理？" class="headerlink" title="springboot外部tomcat原理？"></a>springboot外部tomcat原理？</h1><p>1.打包方式设置为war</p><p>2.将内置的tomcat依赖排除</p><p>3.继承SpringServletInitializer重写configure，将启动类传进去</p><h1 id="读取配置文件原理和加载顺序优先级？"><a href="#读取配置文件原理和加载顺序优先级？" class="headerlink" title="读取配置文件原理和加载顺序优先级？"></a>读取配置文件原理和加载顺序优先级？</h1><p>通过时间监听的方式读取配置文件：ConfigFileApplicationListener</p><p> 优先级为主，高优先级的配置覆盖低优先级的配置，配置会形成互补配置</p><h1 id="springboot的默认日志实现框架是什么？"><a href="#springboot的默认日志实现框架是什么？" class="headerlink" title="springboot的默认日志实现框架是什么？"></a>springboot的默认日志实现框架是什么？</h1><p>默认是logback</p><p>怎么切换成别的？排除logback，添加slf4j的对应的桥接器和适配器就可以了</p><h1 id="springboot可以同时处理多少请求？"><a href="#springboot可以同时处理多少请求？" class="headerlink" title="springboot可以同时处理多少请求？"></a>springboot可以同时处理多少请求？</h1><p><em>server.tomcat.threads.min-spare</em>：最小线程数。</p><p>*server.tomcat.threads.*max：最大线程数。</p><p>*server.tomcat.*max-connections：最大连接数。</p><p>*server.tomcat.*accept-count：最大等待数。</p><p>当连接请求过来时，首先会交给min-spare线程处理，当min-spare线程处理不过来时，会创建临时线程来处理，创建的临时线程数量+min-spare线程数量不能超过max线程数量，即最大线程数量不能超过max个线程。</p><p>max-connections是最大的连接数，当连接数超过max-connections的时候，连接会进入等待队列；accept-count即为等待队列的长度。当等待队列也满了后，连接请求将会进行等待（等待时间大小为客户端设置的连接时间大小），如果在等待连接时间内，有连接处理完成，那么连接请求就能进入等待队列里等待执行；如果在等待连接的时间内，没有连接处理完成，则连接请求将会出现connected timeout异常。</p><p>所以，springboot内置的tomcat同时能处理的请求数量等于：max-connections数量+accept-count数量。max-connection默认值为8192，accept-count默认值为100，所以默认能同时处理的请求个数为8292。</p><h1 id="springboot解决跨域的5种方式"><a href="#springboot解决跨域的5种方式" class="headerlink" title="springboot解决跨域的5种方式"></a>springboot解决跨域的5种方式</h1><p>1.jsonp</p><p>2.跨域请求CORS，ie10以下的浏览器不兼容</p><p>3.nginx：反向代理</p><h1 id="springboot读取配置的6种方式？"><a href="#springboot读取配置的6种方式？" class="headerlink" title="springboot读取配置的6种方式？"></a>springboot读取配置的6种方式？</h1><p>1.属性加@Value(“${get.name}”)可以直接获取到配置文件的值，必须是一个bean</p><p>2.ConfigurationProperties(prefix=”get”) 指定配置文件的前缀，适用于批量绑定 </p><p>3.注入Environment属性，实现接口EnvironmentAware重写set方法来设置environment属性</p><p>4.外部自定义的使用@PropertySource注解绑定外部的配置类</p><p>5.通过注入Bean为PropertySourcesPlaceholderConfigurer的对象来注入yml文件</p><h1 id="springboot如何优化启动速度？"><a href="#springboot如何优化启动速度？" class="headerlink" title="springboot如何优化启动速度？"></a>springboot如何优化启动速度？</h1><p>1.延迟初始化Bean，将bean设置为懒加载</p><p>2.创建扫描索引</p><p>3.升级SpringBoot新版本</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/09/10/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/09/10/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC的理解？原理？实现？"><a href="#IOC的理解？原理？实现？" class="headerlink" title="IOC的理解？原理？实现？"></a>IOC的理解？原理？实现？</h2><p>谁控制谁：在之前我们都是想要什么对象需要自己来new，现在我们都将对象交给ioc容器来控制</p><p>控制什么：实现过程中所需及要依赖的对象</p><p>什么是反转：是由ioc容器创建之后注入到对象中，由主动创建变成了被动接收</p><p>哪些方面被反转：依赖的对象</p><p>总：</p><p>控制反转：理论思想，原来的对象是由使用者自己来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理，DI：依赖注入，把对应的属性值注入到具体的对象中，使用@Autowired注解，populateBean方法来完成属性值的注入</p><p>容器：存储对象，使用map结构来进行存储，在spring中一般存在三级缓存，singletonObjects存放完整的bean对象，整个bean的生命周期，从创建到使用销毁的全过程都是由容器来管理</p><p>ioc他主要的思想就是控制反转和ioc容器，控制反转就是我们以前的对象要自己手动创建来控制，现在我们将对象交给ioc容器来管理，DI依赖注入，使用@Autowried将我们对应的属性值注入到对象中，populateBean方法完成对象属性的填充。ioc容器就是用来存储对象的，使用map结构来存储，一般存在三级缓存，一级缓存存放完整的对象，整个bean的生命周期，从创建到销毁都由容器来管理。</p><h2 id="Spring-bean容器的生命周期？"><a href="#Spring-bean容器的生命周期？" class="headerlink" title="Spring bean容器的生命周期？"></a>Spring bean容器的生命周期？</h2><p>1.实例化bean对象</p><p>通过反射的方式进行对象的创建，只是在堆空间中申请空间，属性都是默认值</p><p>2.填充bean的属性</p><p>给对象的属性设置值，比如使用set或者@autowried设置值，populateBean(),循环依赖的问题（三级缓存）</p><p>3.调用Aware相关接口的方法</p><p>如果对象中需要引用容器内部的对象，需要调用aware接口的子类方法来进行统一的设置</p><p>完成BeanName，BeanFactory，BeanFactory，BeanClassLoader对象的属性设置</p><p>4.BeanPostProcessor的前置处理</p><p>对生成的bean对象进行前置的处理工作</p><p>5.检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法</p><p>判断当前bean对象是否设置了InitializingBean接口，然后进行属性的设置等基本工作</p><p>6.检车是否配置有自定义的init-method方法</p><p>如果当前bean对象定义了初始化方法，那么在此处调用初始化方法</p><p>7.BeanPostProcessor后置处理</p><p>对生成的bean对象进行后置的处理</p><p>执行完一系列的操作就可以使用getBean来获取对象了</p><p>8.注册必要的Destruction相关回调接口</p><p>方便对象进行销毁的操作</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>通过为 目标类 织入切面 的方式，实现对目标类的增强。根据织入的时间点不同可以选择不同的时机进行织入：</p><p>1.编译器织入：将两个.java文件，编译为一个.class文件，依赖编译器</p><p>2.类加载器织入：将两个.class文件，加载到classLoder类加载器，在内存中就是字节数组，然后进行数组的合并，自定义类加载器或类转换器横切逻辑织入到目标类中，然后修改.class文件交给jvm加载，这种织入方式叫LTW</p><p>3.运行期织入：等类加载到内存中，通过动态代理方式proxy、cglib生成子类来完成织入</p><p>aop和aspect互补，不是竞争</p><h2 id="谈谈你对AOP的理解？"><a href="#谈谈你对AOP的理解？" class="headerlink" title="谈谈你对AOP的理解？"></a>谈谈你对AOP的理解？</h2><p>作用：面向切面编程，主要是用来在业务上做解耦的。</p><p>话术解释：将公共业务代码逻辑抽象出一个切面，然后注入到目标对象的业务中，比如日志，事务，权限等核心服务组件，AOP就是这么执行的，通过动态代理的方式，将需要注入切面的对象进行代理，在调用的时候，将公共逻辑直接添加进去，不需要更改原有的业务逻辑，只是在原有的业务基础逻辑上做了一些增强功能。</p><p>切面Aspect：关注点的模块化，在service方法中前后进行方法增强</p><p>连接点Join Point：程序执行过程中特定的点，比如方法调用的时候和处理异常的时候</p><p>通知advice:把通知放在连接点的前边或者后边</p><p>切入点Poincut:匹配连接点的断言表达式</p><p>引入Introduction:允许引入新的接口以及一个对应的实现到任何被代理的对象。</p><p>目标对象 Target：被一个或多个切面所通知的对象</p><p>AOP代理：在Spring中可以是jdk动态代理或者CGLIB代理</p><p>织入：把切面连接到其他应用程序或对象上</p><p>总：aop概念，应用场景，动态代理</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>aop是ioc的一个扩展功能，只是在ioc的整个流程中新增的一个扩展点。</p><p>在bean的创建过程中可以对bean进行扩展实现：</p><p>1.代理对象创建的过程 advice，切面，切点</p><p>2.通过jdk或者cglib的方式来生成代理对象</p><h1 id="Spring的传播事务？"><a href="#Spring的传播事务？" class="headerlink" title="Spring的传播事务？"></a>Spring的传播事务？</h1><p>事务的传播特性指的是不同方法的嵌套调用过程中，事务该如何进行处理，是一个事务还是不同的事务，当出现异常的时候会还是提交，在日常工作中常用的是REQUIRED、REQUIRED_NEW、NESTED</p><h2 id="传播特性有7种"><a href="#传播特性有7种" class="headerlink" title="传播特性有7种"></a>传播特性有7种</h2><p>REQUIRED：默认传播特性，如果当前事务存在，就用这个事务，如果当前事务不存在，就新建一个事务。</p><p>REQUIRED_NEW：不管当前没有事务的存在，都会新建一个新事物。</p><p>NESTED：如果当前存在事务，则在嵌套事务中执行，否则和REQUIRED执行的操作一样。嵌套事务：在事务A方法中设置一个保存点，如果事务B在执行中出现错误则会回滚。</p><p>SUPPORTS:如果当前事务存在，就用这个事务，如果当前不存在事务，就使用非事务的方式。</p><p>NOT_SUPPORTS：以非事务的方式执行，如果存在事务，则挂起事务不让他执行。</p><p>NEVER:如果存在事务就会抛出异常，如果不存在事务就会正常允许。</p><p>MANDATORY:如果当前事务存在，就用这个事务，如果不存在事务，就会抛出异常。</p><p>NESTED和REQUIRED_NEW的区别：</p><p>REQUIRED_NEW是新建一个事务并且新开始的这个事务与原有事务无关，而NESTED则是当前存在事务时会开启一个嵌套事务，在NESTED情况下，父事务回滚时，子事务也会回滚，而REQUIRED_NEW情况下，原有事务回滚，不会影响新开启的事务</p><p>NESTED和REQUIRED的区别：</p><p>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一个事务，那么被调用方出现异常时，由于共用一个事务,所以无论是否catch异常,事务都会回滚,而在NESTED情况下,被调用方发生异常时,调用方可以catch其异常，这样只有子事务回滚，父事务不会回滚。</p><h2 id="Spring用到了哪些设计模式及应用场景？"><a href="#Spring用到了哪些设计模式及应用场景？" class="headerlink" title="Spring用到了哪些设计模式及应用场景？"></a>Spring用到了哪些设计模式及应用场景？</h2><p>工厂模式：在各种BeanFactory以及ApplicationContext创建中用到了</p><p>模块模式：让子类扩展实现</p><p>代理模式：Aspect AOP的底层用了动态代理，jdk，cglib</p><p>策略模式：进行不同的操作要用不同的方法实现逻辑来处理</p><p>单例模式：在创建bean的时候</p><p>观察者模式：容器刷新</p><p>适配器模式：springmvc上的Adapter</p><p>装饰者模式：源码带Wrapper或者Decorator都是对象的封装，提供一些属性的插入</p><h3 id="Spring是如何解决循环依赖的问题的？"><a href="#Spring是如何解决循环依赖的问题的？" class="headerlink" title="Spring是如何解决循环依赖的问题的？"></a>Spring是如何解决循环依赖的问题的？</h3><p>三级缓存，提前暴露对象，aop</p><p>什么是循环依赖问题：A依赖B，B依赖A</p><p>先说明bean的创建过程，先实例化，然后初始化（填充属性）</p><p>形成闭环的原因：</p><p>先创建A对象，实例化A对象，此时A对象中的b属性为空，填充属性b</p><p>从容器中查找B对象，如果找到了直接赋值不存在循环依赖问题（不通），找不到直接创建B对象</p><p>实例化B对象，此时B对象中的a属性为空,填充属性a</p><p>从容器中查找A对象，找不到直接创建</p><p>仔细琢磨的话，会发现A对象是存在的，只不过此时的A对象不是一个完整状态，只是完成了实例化但是未初始化。在调用过程中，拥有了某个对象的引用，能否在后期完成赋值操作，可以优先把非完整状态对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整的对象引用，核心在于实例化和初始化分开操作，这也是解决循环依赖问题关键。</p><p>当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时容器存在两个状态实例化未初始化、完整状态，都在容器中，用不同的map结构来存储，此时就有了一级缓存和二级缓存，如果一级缓存有，那么二级缓存就不会存在同名的对象，因为他们的查找顺序是1级、2级、3级这样的方式来查找的，一级存放的是完整对象，二级存放的是非完整对象</p><p>为什么需要三级缓存？三级缓存的value类型是Object是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean只能有一个。</p><p>如果一个对象需要被代理，或者说需要生成对象，那么要优先创建一个普通对象。</p><p>普通对象和代理对象不能同时出现在容器中，因此当一个对象需要被代理的时候，就要用代理对象覆盖之前的普通对象，在实际的调用过程中，是没有办法确定什么时候被使用，所以当某个对象被调用的时候，优先判断此对象是否被代理，类似于一种回调机制的实现，可以通过lamdba表达式来执行对象的覆盖过程。</p><h3 id="缓存的放置时间和删除？"><a href="#缓存的放置时间和删除？" class="headerlink" title="缓存的放置时间和删除？"></a>缓存的放置时间和删除？</h3><p>三级缓存：createBeanInstance之后，addSingletonFactory</p><p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存getSingleton</p><p>一级缓存:生成完整对象之后放到一级缓存，删除二三级缓存 addSingleton</p><h3 id="BeanFactory和Factorybean有什么区别？"><a href="#BeanFactory和Factorybean有什么区别？" class="headerlink" title="BeanFactory和Factorybean有什么区别？"></a>BeanFactory和Factorybean有什么区别？</h3><p>相同点：都是用来创建bean对象的</p><p>不同点：使用BeanFactory创建对象的时候，必须遵循严格的生命周期，如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，就需要实现Factorybean接口了</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/09/10/JVM/"/>
      <url>/2023/09/10/JVM/</url>
      
        <content type="html"><![CDATA[<h3 id="JVM的组成部分？"><a href="#JVM的组成部分？" class="headerlink" title="JVM的组成部分？"></a>JVM的组成部分？</h3><h5 id="类加载器子系统ClassLoader"><a href="#类加载器子系统ClassLoader" class="headerlink" title="类加载器子系统ClassLoader"></a>类加载器子系统ClassLoader</h5><p>作用：负责从文件系统或网络中加载Class文件，class文件在文件开头有特定的文件标识；</p><p>​            ClassLoader只负责class文件的加载，运行由Execution Engine决定；</p><p>​            加载类信息存放于方法区的内存空间。方法区除了类信息，还会存放运行时常量池，还可能包含字符串字面量和数字常量；</p><p>类加载的生命周期：加载→链接（验证、准备、解析）→初始化→使用→卸载</p><p>加载loading：JVM对class对象是按需加载，加载到内存生成class对象，采用双亲委派模型加载</p><p>1.通过类的全限定类名获取到此类的二进制字节流</p><p>2.将这个字节流所代表的静态存储结构转化为方法区运行时数据结构</p><p>3.在内存中生成一个代表这个类的大Class对象，作为方法区这个类的各种数据入口</p><p>链接Linking：验证-准备-解析</p><p>验证：文件格式验证、元数据验证、字节码验证、符号引用验证</p><p>准备：为类的变量分配 内存并且设置该类的默认初始值（不包含final修饰的static，因为final在编译的时候就会分配，也不会给实例变量初始化）</p><p>解析：将常量池内的符号引用转换为引用的过程</p><p>初始化initialization</p><p>为类的静态变量进行赋予正确的值</p><p>插件：bytecode viewer、jclasslib bytecode viewer</p><p>可以可视化已编译Java类文件和所包含的字节码的工具。 另外，它还提供一个库，可以让开发人员读写Java类文件和字节码。</p><p>类加载器的分类？</p><p>引导类加载器（Bootstrap ClassLoader）：使用c++实现的，系统的核心类库都是使用引导类加载器加载的</p><p>扩展类加载器（Extension ClassLoader）：获取上层记载器是空</p><p>系统类加载器（System ClassLoader）:获取其上层加载器是扩展类加载器，定定义的类是系统类加载器加载的</p><p>自定义类加载器（User-Defined ClassLoader）</p><h6 id="双亲委派机制？"><a href="#双亲委派机制？" class="headerlink" title="双亲委派机制？"></a>双亲委派机制？</h6><p>Java虚拟机对class采用的是按需加载，也就是说当需要使用该 类的时候才会将class文件加载到内存生成class对象，而加载类的时候，java虚拟机使用的是双亲委派模式，就是把请求都交给父类类处理，是一种委派模式。</p><p>工作原理：</p><p>如果一个类加载器收到了加载请求，他不会自己去加载，而是委托给父类的加载器是执行。</p><p>如果父类加载器还存在其父类加载器，则向上委托，依次递归</p><p>如果父类加载器完成类的加载任务，就成功。如果父类加载器无法此任务，子加载器会尝试自己加载。</p><p>优势：</p><p>避免类的重复加载</p><p>防止核心的API被随意篡改</p><p>沙箱安全机制：保证源代码的保护</p><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><h5 id="程序计数器-PC-Register"><a href="#程序计数器-PC-Register" class="headerlink" title="程序计数器(PC Register)"></a>程序计数器(PC Register)</h5><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><ul><li>作用:存储指向下一条指令的地址代码，由执行引擎读取下一条指令（偏移地址 ）。</li><li>特点：<ul><li>线程是私有的，独有一份</li><li>不会存在内存溢出</li></ul></li></ul><p>使用PC寄存器存储字节码指令地址有什么用呢？</p><p>因为CPU需要不停的切换各个线程，这时候切换回来，就得知道接着从哪执行 </p><p>PC寄存器为什么设定为私有的？</p><p>一个cpu核执行多个线程，线程进行一个切换，每个线程切换之后会记录自己的地址值，执行到了哪一步</p><h5 id="栈（Stacks）"><a href="#栈（Stacks）" class="headerlink" title="栈（Stacks）"></a>栈（Stacks）</h5><ul><li><p>栈：每个线程运行都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的Java方法调用，是线程私有的</p></li><li><p>栈帧：每个方法运行时需要的内存（局部变量（基础数据类型、对象的引用地址），参数，返回地址），每个栈由多个栈帧组成，对应着每次方法调用所占用的内存</p></li><li><p>每个线程只能一个活动栈帧，对应着正在执行的那个方法</p></li><li><p>特点：</p><ul><li>先进后出</li></ul></li><li><p>问题？</p></li><li><p>垃圾回收是否涉及栈内存？</p><p>不会涉及，因为在每个方法执行结束之后，自动会出栈，无需进行垃圾回收处理，只有堆内存的对象才需要进行垃圾回收管理。</p></li><li><p>栈内存分配越大越好吗？</p><p>不会，如果栈内存分配的越大，线程数会变小，因为我们的物理内存是一定的，分配的越大线程数则会变小，从而影响我们的运行速度，栈内存分配不是越大越好，它分配大了只是能够进行多次方法的递归调用，而不会增快程序的运行效率，反而会影响线程数目的变小。一般采用默认就可以，不必在程序启动的时候手动修改。</p></li><li><p>方法内的局部变量是否是线程安全？</p><p>当方法内局部变量没有逃离方法的作用访问时线程安全，因为一个线程对应一个栈，每调用一个方法就会产生一个栈帧，都是线程私有的局部变量，当变量是static时则不安全，因为是线程共享的。</p><p>如果局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全。</p><ul><li>栈内存溢出？</li></ul><p>栈帧过多导致内存溢出（递归调用）</p><p>栈帧内存过大导致内存溢出</p><p>循环引用  </p></li><li><p>线程诊断</p><p>用top命令定位哪个进程对cpu占用过高。命令：ps H -eo pid,tid,%cpu|grep 进程id</p><p>jstack 进程id 可以根据线程id找到 ，进一步定位到问题代码的源码行号</p></li><li><p>运行很长时间没有找到结果</p></li></ul><h6 id="栈运行原理？"><a href="#栈运行原理？" class="headerlink" title="栈运行原理？"></a>栈运行原理？</h6><p>JVM对java栈的操作只有压栈、出栈，在一条活动线程中，一个时间点，只会有一个活动的栈帧，只有当前在执行的方法的栈帧是有效的，称为当前栈帧，与当前栈帧对应的方法是当前方法，定义这个方法的类就是当前类。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈。</p><p>如果当前方法调用了其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机丢弃当前栈帧，使得前一个栈帧成为当前栈帧</p><p>Java方法有两种返回函数的方式：一种是正常的函数返回，使用return指令；另外一种是抛出异常。这两种方式都会栈帧被弹出</p><h6 id="栈帧的内部结构？"><a href="#栈帧的内部结构？" class="headerlink" title="栈帧的内部结构？"></a>栈帧的内部结构？</h6><p>局部变量表：定义一个数字数组，存储方法参数和定义在方法的局部变量，这类数据包括基本数据类型、对应引用、返回类型，局部变量表所需要的容量大小是在编译期确定下来的</p><p>JVM中的每个Solt都分配了一个索引，通过索引就可以成功访问局部变量表中指定的局部变量值。</p><p>当一个实例方法被调用的时候，方法参数和方法体内定义的局部变量将会被复制到局部变量表中的每一个Slot上。</p><p>访问64bit的局部变量时，只需要使用前边的第一个索引即可（比如long或double的变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，该对象引用this将会放在index为0的slot处，其余的参数按照参数表继续排列</p><p>槽是可以重复使用的，局部变量过了其作用域，新的变量就会复用过期局部变量的槽位 </p><p>按照数据类型分：基本数据类型、引用数据类型</p><p>按照位置分：成员变量：在使用前都会进行赋默认值，类变量：在linking的prepare阶段给变量默认值，initial阶段给类变量显式赋值及                        静态代码块赋值，实例变量随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</p><p>​                        局部变量：在使用前，必须显示赋值！否则编译不通过</p><p>操作数栈（或表达式栈）：对应着每一条jvm字节码指令</p><p>动态链接（指向运行时常量池的方法引用）</p><p>常量池编译后在栈帧中的动态链接是用符号#12来显示的，当我们运行的时候，在方法区也会加载一份，栈帧中的符号指向运行时常量池的地址值</p><p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p><p>方法返回地址（方法正常退出或者异常推出的定义）</p><p>一些附加信息</p><h5 id="Native-Method-Stacks-本地方法栈"><a href="#Native-Method-Stacks-本地方法栈" class="headerlink" title="Native Method Stacks 本地方法栈"></a>Native Method Stacks 本地方法栈</h5><p>调用其他编程语言编写的底层代码</p><h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h5><h6 id="堆的概述注意点"><a href="#堆的概述注意点" class="headerlink" title="堆的概述注意点"></a>堆的概述注意点</h6><p>一个JVM实例只存在一个堆内存，堆内存在JVM启动的时候就被创建，其空间大小也确定了，堆内存的空间大小是可以调节的。</p><p>堆可以处于物理上不连续的内存空间中，但是在逻辑上是连续的（栈帧和堆形成映射表，栈帧是连续入栈，所以在方法执行的时候相当于是有续的）。</p><p>所以的线程共享堆，在堆里还能划分线程私有的缓冲区（ThredLocal Allocation Buffer，TLAB）</p><p>几乎所有的对象实例都在堆分配内存。(<em>逃逸分析利用标量替换实现堆上的对象分解为栈上的标量</em>)</p><p>数组和对象可能永远不会存储在栈上，因为栈帧保存引用，引用指向对象或数组在堆中的位置。</p><p>在整个方法结束后，堆中的对象不会马上被移除，仅仅是在垃圾回收的时候才会被回收。</p><p>通过new关键字，创建对象都会使用堆内存</p><h6 id="JDK7和JDK8的变化"><a href="#JDK7和JDK8的变化" class="headerlink" title="JDK7和JDK8的变化"></a>JDK7和JDK8的变化</h6><ul><li><p>JDK8之后元空间取代了永久代，JDK8没有了PermSize相关的参数配置：XX:PermSize 和 -XX:MaxPermSize 已经失效。</p></li><li><p>元空间使用本地内存（系统内存），永久代使用虚拟机堆中内存。</p></li><li><p>JDK1.6及之前：有永久代，静态变量存放在永久代上</p></li><li><p>JDK1.7：有永久代，但逐步移除永久代，字符串常量池、静态变量移除，保存在堆中</p></li><li><p>JDK1.8：无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆中</p></li><li><p>stringtable调整的原因是永久代回收效率低，在full gc的时候才会触发，而full gc是老年空间的不足、永久代不足时才会触发，导致StringTable回收效率不高，在正常的开发中，我们会创建大量的字符串，回收效率低会导致永久代内存不足，放到堆里可以及时回收。</p></li></ul><h6 id="设置堆空间的内存大小"><a href="#设置堆空间的内存大小" class="headerlink" title="设置堆空间的内存大小"></a>设置堆空间的内存大小</h6><p>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小（X 是jvm的运行参数， ms 是memory start）</p><p>-Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</p><p>默认堆空间的大小</p><p>初始内存大小：物理电脑内存大小 / 64</p><p>最大内存大小：物理电脑内存大小 / 4</p><p>手动设置：-Xms600m -Xmx600m（开发中建议将初始堆内存和最大的堆内存设置成相同的值。）</p><ul><li><p>特点</p><p>它是线程共享的，堆中对象都需要考虑线程安全的问题</p><p>有垃圾回收机制</p></li><li><p>堆内存诊断工具 </p><p>jps工具：查看当前系统有哪些java进程（jps   /  jstat -gc 进程id）</p><p>方式二：设置-XX:+PrintGCDetails参数可以在控制台打印</p><p>jmap工具：查看堆内存占用情况</p><p>jconsole工具：图像界面，多功能的监测工具，可以连续监测        </p></li></ul><h6 id="堆空间中的年轻代与老年代"><a href="#堆空间中的年轻代与老年代" class="headerlink" title="堆空间中的年轻代与老年代"></a>堆空间中的年轻代与老年代</h6><p>JAVA堆区可以进一步划分为年轻代（YoungGen）和老年代（ OldGen），其中年轻代可以划分为Eden空间（伊甸园）、Survivor0空间和Survivor1空间（有时候也叫from区、to区）</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>如果修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li><li>启动参数： -Xms600m -Xmx600m -XX:+UseAdaptiveSizePolicy（打开自适应的内存分配策略）</li><li>启动参数： -Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy（关闭自适应的内存分配策略）</li><li>启动参数： -Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy（关闭自适应的内存分配策略）</li></ul><h6 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h6><p>1.new的对象先放到伊甸园区。大小对象的区分：如果是大对象，直接出发gc分配到老年区（尽量避免程序中出现过多的大对象）</p><p>2.当伊甸园区空间填满之后，程序又要创建对象，JVM的垃圾回收器将对伊甸园区和存活区进行垃圾回收（Minor Gc）,将不再被其他对象引用的对象进行销毁，然后将伊甸园中剩余的对象移动到幸存者TO区，再将新的对象放到伊甸园区。</p><p>3.如果伊甸园再次触发gc的话，将上次TO区的对象并且包含本次垃圾回收后的幸存者存入TO区。（针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to区.）</p><p>4.移动到To区的对象年龄每次+1，年龄超过15晋升为老年区，默认为15次。可以设置参数: -XX:MaxTenuringThreshold=N次 进行设置。</p><p>5.当老年区内存不足时，再次触发GC: Major GC, 进行养老区的内存清理。</p><p>6.若老年区执行了Major GC之后还发现无法进行对象的保存，就会产生OOM异常。</p><p>总结：</p><p>针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to区.</p><p>关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区，元空间收集。</p><p>如果对象在Eden出生并经过第一次MinorGC 后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor、区中每熬过一次MinorGC ，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。</p><p>对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置。</p><h6 id="针对不同年龄段的对象分配原则"><a href="#针对不同年龄段的对象分配原则" class="headerlink" title="针对不同年龄段的对象分配原则"></a>针对不同年龄段的对象分配原则</h6><ul><li><p>优先分配到Eden</p></li><li><p>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</p></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p><h6 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h6></li><li><p><em>Jconsole</em></p></li><li><p><em>VisualVM</em></p></li><li><p><em>Jprofiler</em></p></li><li><p>JDK命令行</p></li><li><p>Eclipse :Memory Analyzer Tool</p></li><li><p>Java Flight Recorder</p></li><li><p>GCViewer</p></li><li><p>GC Easy</p></li></ul><h6 id="三种GC区别"><a href="#三种GC区别" class="headerlink" title="三种GC区别"></a>三种GC区别</h6><p>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对HotSpotVM的实现，它里面的GC按照回收区域又分为两大种类型:</p><p>1.部分收集</p><ul><li><p>新生代收集(Minor GC/Young GC):只是新生代(Eden\S0,S1)的垃圾收集。</p><p>触发机制：当年轻代空间不足时， 就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存。)</p><p>​                    MinorGC非常频繁，一般回收速度也比较快。</p><p>​                    Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p></li><li><p>老年代收集(Major GC/0ld GC):只是老年代的垃圾收集。（目前，只有CMS GC会有单独收集老年代的行为。）</p><p>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</p><ul><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。如果Major GC后，内存还不足，就报OOM了。</li></ul></li><li><p>混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。（目前只有G1 GC会有这种行为）</p></li><li><p>FUll GC触发机制</p><p>老年代空间不足、方法区空间不足</p><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><p>由Eden区、s0区向s1区复制时，对象大小大于To区（幸存者区）可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p></li></ul><p>2.整堆收集</p><ul><li>收集整个java堆和方法区的垃圾收集。</li></ul><h6 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h6><p>java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）</p><h6 id="堆为什么进行分代？"><a href="#堆为什么进行分代？" class="headerlink" title="堆为什么进行分代？"></a>堆为什么进行分代？</h6><p>因为对象的生命周期不同，分开好管理。</p><p>有利于提高垃圾回收效率，把生命周期较短的对象区域进行回收，这这也就可以腾出很大一部分的空间。</p><h6 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h6><ul><li><p>TLAB(Thread Local Allocation Buffer) 线程私有的分配缓冲区。</p></li><li><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p></li><li><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。提升分配效率</p></li><li><p>为什么需要TLAB</p></li><li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p></li><li><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p></li><li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p></li></ul><p>逃逸分析不成熟.</p><h5 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h5><p>JDK1.6方法区：PermGen永久代，包含class类,ClassLoader类加载器，常量池、字符串常量池StringTable，使用的是堆空间。</p><p>JDK1.8元空间：PermGen永久代被废弃，方法区变为元空间，包含class类，ClassLoader类加载器，常量池，使用的是本地内存，StringTable字符串常量池是在堆中。</p><p>内存溢出：因为在1.8直接是用的本机pc内存非常的大，很难模仿出元空间溢出的现象，所以需要参数- XX：MaxPermSize=8m来指定他的元空间大小。</p><p>User user = new User();User是类型 user是引用，存放到栈帧中的  new User()是指向堆空间的一块区域</p><p> 方法区包含了运行时常量池：在字节码文件中有常量池Constant Pool，classLoader将字节码加载到方法区就成了运行时常量池，所以是在方法区的</p><p>常量池：常量池就是一张表，虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类 型、字面量等信息。二进制字节码包含（类基本信息，常量池，类方法定义，虚拟机指令）</p><p>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分在类加载之后存放到方法区的运行时常量池</p><p>运行时常量池：常量池是在.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并且把里边的符号地址变为真是的地址。</p><h4 id="关于对象的相关内容"><a href="#关于对象的相关内容" class="headerlink" title="关于对象的相关内容"></a>关于对象的相关内容</h4><h5 id="对象实例化步骤"><a href="#对象实例化步骤" class="headerlink" title="对象实例化步骤"></a>对象实例化步骤</h5><p>1.加载类元信息</p><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。</p><p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p><p>类加载阶段：加载、链接（验证-&gt;准备-&gt;解析）、初始化</p><p>2.为对象分配内存</p><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量（地址）空间即可，即4个字节大小。对象大小具体算。</p><ul><li><p>如果内存规整，使用指针碰撞</p></li><li><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bump The Pointer) 来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虛拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p></li><li><p>如果内存不规整，使用空闲列表</p></li><li><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为：空闲列表(Free List)。</p><p>说明:选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p></li></ul><p>3.处理并发问题</p><p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性，创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题:</p><ul><li>CAS(Compare And Swap)失败重试、区域加锁:保证指针更新操作的原子性</li><li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。(堆篇章已介绍)</li></ul><p>4.属性的默认初始化</p><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接调用使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>5.设置对象的对象头</p><p>将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>6.属性的显示初始化、构造代码块初始化、构造器初始化（执行init方法进行初始化）</p><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行构造代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespeclal指令所决定)， new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p><p>注意：</p><p>静态变量和静态代码块的默认初始值是在类加载阶段的链接阶段来初始化的，显式初始化赋值是在clint阶段完成的。</p><ol><li>JOT可以查询对象大小，引入如下依赖：</li></ol><dependency>    <p>​        <groupId>org.openjdk.jol</groupId>    </p><p>​        <artifactId>jol-core</artifactId>    </p><p>​        <version>0.16</version></p> </dependency><p>对象内存的布局</p><p>1.对象头包含两部分：运行时元数据和类型指针</p><p>运行时元数据：哈希值、GC分代年龄、锁状态标准、线程持有的锁、偏向线程ID、偏向时间戳</p><p>类型指针：指向类元数据InstanceKlass，确定该对象的所属类型</p><p>2.实例数据：包括程序中定义的各种数据类型字段（包含父类继承下来的和本身的字段），规则是先放父类的变量，从父类加载开始</p><p>3.对其填充：占位符的作用</p><h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存是在Java堆外的、直接向系统申请的内存区间</p><ul><li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p></li><li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p></li><li><p>也可能导致OutOfMemoryError异常</p></li><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xnx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><p>-XX:MaxDirectMemorySize=大小：设置直接内存；如果不指定，默认与堆的最大值-Xmx参数值一致</p><p>缺点：分配回收成本较高、不受JVM内存回收管理</p><p>非直接缓存区：读写文件，需要与磁盘交互，需要由用户态切换到内核态。这里需要两份内存存储重复数据，效率低。</p><p>直接缓存区：使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p></li></ul><h5 id="StringTable-字符串常量池"><a href="#StringTable-字符串常量池" class="headerlink" title="StringTable 字符串常量池"></a>StringTable 字符串常量池</h5><p>常量池中的信息，都会被加载到运行时常量池，都是常量池中的符号，还没有变为java字符串对象，会先去串池里找，如果串池里没有就会放入到串池，如果有就会用串池的，取值对象也是唯一的</p><p>#2符号会把a符号变为“a”字符串对象</p><p>String s1 = “a”;惰性的，是一行一行记载的，相同的则不加载</p><p>StringTable[“a”,”b”,”ab”] 是一个hashtable结构，不能扩容</p><p>字符串常量是放到串池的，字符串拼接是重新new了一个新的String对象，他俩的地址值不同</p><h5 id="解释器-执行引擎（Execution-engine）"><a href="#解释器-执行引擎（Execution-engine）" class="headerlink" title="解释器 执行引擎（Execution engine）"></a>解释器 执行引擎（Execution engine）</h5><p>为什么说Java是半编译半解释型语言？</p><p>JDK1.0，将Java语言定位为“解释执行”语言，后来可以直接生成本地代码的编译器，现在JVM执行的时候，通常都会将解释和编译二者结合运行</p><p>热点代码及探测方式</p><p>解释器响应速度快，编译器运行速度快</p><h4 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h4><h5 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h5><p>如何判断一个对象是否存活？（当一个对象不再被任何存活的对象引用时），主要有以下两种算法：引用计数算法、可达性分析算法。</p><h6 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h6><p>一个对象被引用后，引用计数器+1，在没被引用时，引用计数器-1，引用计数器为0的时候，表示该对象没被引用，可以进行回收。</p><p>引用计数器的缺点：不能解决循环引用的问题。（对象A引用了对象B，然后对象又去引用了对象A，形成了一个循环），使用引用计数器的语言有python，解决循环引用的办法是手动解除循环引用的关系</p><h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>别名：根搜索算法、追踪性垃圾算法</p><p>优点：可以有效解决循环引用的问题，防止内存泄漏的问题</p><p>基本思路：</p><p>（1）是以根对象集合GC roots为起点，开始按照从上至下的方式搜索，被根对象集合所连接的目标对象是否可达。</p><p>（2）存活对象:使用该算法之后，存活的对象会被根对象集合直接或间接连接着，该路径成为引用链。</p><p>（3）垃圾对象:如果目标对象没有被任何引用链相连，可以标记为垃圾对象。</p><h5 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h5><p>JVM常见的三种垃圾收集算法是标记-清除算法、复制算法、标记-压缩算法</p><h6 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark - Sweep）"></a>标记-清除算法（Mark - Sweep）</h6><p>当堆中的有效空间被耗尽时，就会停止整个程序，然后进行标记-清除</p><p>标记：就是使用可达性分析算法从根节点进行遍历，标记所有被引用的对象，在对象的header头中记录可达对象。</p><p>清除：在堆内存中从头到尾进行线性的遍历，发现某个对象在header中没有标记为可达对象，则会回收。</p><h6 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h6><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p>复制算法是建立在存活对象少，垃圾对象对象多的前提下的，这种情况一般发生在新生代，但是在老年代大部分都是存活对象，如果依然使用复制算法，复制的对象较多，复制成本也是非常的高，需要使用其他的算法。标记清除算法的确可以使用在老年代，但是算法的执行效率低下，在执行完内存回收时还会产生碎片，所以需要进行改进，由此诞生的算法才是标记-压缩算法。</p><h6 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark - Compact）"></a>标记-压缩算法（Mark - Compact）</h6><p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用的对象。</p><p>第二阶段将所有内存对象压缩到内存的一端，按照之前存活对象之后的顺序排放（JVM只需要有一个内存的起始地址即可）， 之后清除边界外所有的空间。</p><p>标记-压缩最后的效果等同于标记-清除算法执行完之后，再进行一次碎片整理，也可以称之为标记-清除-压缩算法。</p><h5 id="System-gc的理解？"><a href="#System-gc的理解？" class="headerlink" title="System.gc的理解？"></a>System.gc的理解？</h5><p>在默认情况下，通过System.gc()实则是调用Runtime.getRuntime().gc()，会显式触发Full GC， 同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p><em>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</em></p><p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而-一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p><h5 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h5><p>内存泄漏（memory leak） :是指程序在申请内存后，无法释放已申请的内存空间（即使对象不再使用了，但是虚拟机没有释放），一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p><p>内存溢出（out of memory） :指程序申请内存时，没有足够的内存供申请者使用，并且垃圾收集器也无法提供更多内存。此时就会报错OOM,即所谓的内存溢出。</p><h6 id="内存泄漏案例"><a href="#内存泄漏案例" class="headerlink" title="内存泄漏案例"></a>内存泄漏案例</h6><p>单例模式：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><p>一些提供close的资源未关闭导致内存泄漏数据库连接(dataSourse.getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p><h6 id="内存溢出解决方案"><a href="#内存溢出解决方案" class="headerlink" title="内存溢出解决方案"></a>内存溢出解决方案</h6><p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数调整)</p><p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</p><p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><p>第四步，使用内存查看工具动态查看内存使用情况</p><p>重点排查以下几点：</p><ul><li>1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li><li>2.检查代码中是否有死循环或递归调用。</li><li>3.检查是否有大循环重复产生新对象实体。</li><li>4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li><li>5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li></ul><h6 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h6><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><ul><li>开发中不要用System.gc(),会导致Stop-the-world的发生。</li><li>G1也不能完全避免Stop-the-world 情况发生</li></ul><h6 id="程序的并发（Concurrent）与并行（Parallel）"><a href="#程序的并发（Concurrent）与并行（Parallel）" class="headerlink" title="程序的并发（Concurrent）与并行（Parallel）"></a>程序的并发（Concurrent）与并行（Parallel）</h6><p>并发（Concurrent）：一个时间段内，且几个程序都是在同一个处理器上运行，并发不是真正意义上的同时进行，只是cpu把一个时间段划分为几个时间片段，着时间区间之间来回切换，由于cpu处理的速度非常快，只要时间间隔处理得当，感觉是多个应用程序同时在进行</p><p>并行（Parallel）：系统有一个以上CPU时，当一个CPU执行一个进程时，另一个cpu在执行另一个进程，连个进程不抢占CPU资源，可以称之为并行，多核也可以进行并行</p><p>在谈论垃圾收集器的上下文语境中，它们可以解释如下:</p><ul><li><p>并行(Parallel) :指</p><p>多条垃圾收集线程并行工作</p><p>，但此时用户线程仍处于等待状态。</p><ul><li>如ParNew、 Parallel Scavenge、 Parallel 0ld;</li></ul></li><li><p>串行(Serial)</p><ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li><li><p>并发(Concurrent) :指用户线程与垃圾收集线程可能会交替执行，</p><ul><li>如: CMS、G1</li></ul></li></ul><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><ul><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safepoint)”</li></ul><p>​        Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂,通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择一些执行时间较长的指令作为SafePoint，如方法调用、循环跳转和异常跳转等。</p><h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</p><ul><li>抢先式中断:(目前没有虚拟机采用了)首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断:设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?</p><p>例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p><ul><li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint。</li><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止;</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public,可以在应用程序中直接使用</p><ul><li><code>强引用(StrongReference)</code> ：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><code>软引用(SoftReference)</code> :在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li><code>弱引用(WeakReference)</code> :被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><code>虚引用(PhantomReference)</code> :一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="强引用-不回收"><a href="#强引用-不回收" class="headerlink" title="强引用-不回收"></a>强引用-不回收</h3><ul><li><em>强引用可以直接访问目标对象。</em></li><li><em>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿拋出OOM异常，也不会回收强引用所指向对象。</em></li><li><em>强引用可能导致内存泄漏。</em></li></ul><h3 id="软引用-内存不足即回收"><a href="#软引用-内存不足即回收" class="headerlink" title="软引用-内存不足即回收"></a>软引用-内存不足即回收</h3><ul><li><p><em>软引用是用来描述一些还有用，但非必需的对象。</em></p></li><li><p><em>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</em></p></li><li><p>软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p></li></ul><h3 id="弱引用-发现即回收"><a href="#弱引用-发现即回收" class="headerlink" title="弱引用-发现即回收"></a>弱引用-发现即回收</h3><p><em>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</em></p><p><em>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</em></p><p>由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><em>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</em> 如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><h3 id="虚引用-对象回收跟踪"><a href="#虚引用-对象回收跟踪" class="headerlink" title="虚引用-对象回收跟踪"></a>虚引用-对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p><em>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</em></p><p><em>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。</em> 比如:能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>终结器引用(Final reference)它用以实现对象的finalize()方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法</p><p>构造函数为私有，无法自己构建这类对象</p><p>第二次GC时才能回收被引用对象。因为只有在FinalizerThread执行完了对象的finalize方法的情况下才有可能被下次gc回收，而有可能期间已经经历过多次gc了，但是一直还没执行f对象的finalize方法</p><p>作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2022/02/21/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/02/21/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><p>通过连续的存储空间，存储相同类型元素的集合</p><p>首元素地址+（索引x元素的宽度）=索引</p><p>内存存储:有序，索引：递增有序</p><p>存储内容：固定，随机访问：高效</p><p>当前数组的长度/当前数组元素的个数length</p><p>索引：从0开始，length-1为当前数组的全部索引</p><p>数组的容量不可变：是因为如果重新给变量赋值，会指向新的数组的引用地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] ints = new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">System.out.println(ints.length);</span><br><span class="line">String[] strings = &#123;&quot;张三&quot;,&quot;李四&quot;&#125;;</span><br><span class="line">System.out.println(strings.length);</span><br><span class="line">//重新复制不能直接使用&#123;&#125;，必须使用new String</span><br><span class="line">strings=new String[]&#123;&quot;小王&quot;&#125;;数组的长度不可变，strings变量的引用指向了新的数组</span><br><span class="line">System.out.println(+strings.length);</span><br><span class="line">//通过索引获取元素，获取索引为0的元素</span><br><span class="line">System.out.println(strings[strings.length-1]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//当前的二维数组指的是这个一维数组的长度是5，每个位置上都是一个长度为2的一维的数组</span><br><span class="line">int[][] array2 = new int[5][2];</span><br></pre></td></tr></table></figure><h1 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h1><h2 id="List-单例集合、有序、元素可重复"><a href="#List-单例集合、有序、元素可重复" class="headerlink" title="List 单例集合、有序、元素可重复"></a>List 单例集合、有序、元素可重复</h2><p>ArrayList：底层是数组，线程不安全，查询快，增删慢</p><p>扩容机制：在JDK1.7的时候，实例化对象之后默认初始化容量为10</p><p>​                    在JDK1.8的时候，实例化对象之后默认初始化容量为0，只有在add的时候才会对数组进行初始化一个为10的容量，每次扩容原来容量的1.5倍，将原来数组的数组原封不动的复制到新的数组里，且将Arraylist的地址指向新数组</p><p>扩容：JDK1.7取余，JDK1.8是位运算右移一位相当于除以2</p><p>关于线程安全的集合类：Vector、Collections.synchronizedList()、原始方法对象+synchronized，CopyOnWriteArrayList</p><h3 id="elementData用transient修饰？"><a href="#elementData用transient修饰？" class="headerlink" title="elementData用transient修饰？"></a>elementData用transient修饰？</h3><ol><li>transient的作用是该属性不参与序列化。</li><li>ArrayList继承了标示序列化的Serializable接口。</li><li>对arrayList序列化的过程中进行了读写安全控制。</li><li>在序列化方法writeObject()方法中可以看到，先用默认写方法，然后将size写出，最后遍历写出elementData，因为该变量是transient修饰的，所有进行手动写出，这样它也会被序列化了。那是不是多此一举呢？ 当然不是，其中有一个关键的modCount, 该变量是记录list修改的次数的，当写入完之后如果发现修改次数和开始序列化前不一致就会抛出异常，序列化失败。这样就保证了序列化过程中是未经修改的数据,保证了序列化安全。</li></ol><p>LinkedList：底层是双向链表、查询慢，增删快，线程不安全</p><p>Linkedlist为什么查询慢，增删快？</p><p>插入和删除只需要改变当前元素的头尾指针，查询需要遍历整个链表直到找到这个元素为止</p><p>LinkedList的查询逻辑</p><p>根据传入的index去判断是否为在0-size区间，如果在这个区间就会进行位移运算，右移一位除以2，判断是在数组的左边还是右边，如果在左边从节结点进行遍历，如果在右节点从最后一个节点进行遍历</p><p>Vector：底层是数组，线程安全，查询快，增删慢</p><p>扩容机制每次扩容原来的2倍（扩容当构造没有capacityIncrement时，一次扩容数组变成原来两倍oldCapacity ，否则每次增加capacityIncrement）</p><p> 删除元素：数组移除某一元素并且移动后，一定要将原来末尾设为null，且有效长度减1。</p><p>Stack基础于Vector也是线程安全的，故其主要操作为push入栈和pop出栈，而栈最大的特点就是LIFO</p><p>Queue：数据结构 先进先出FIFO,从某一段放元素进去的一个容器，取元素只能从另一端取.</p><p>实现类PriorityQueue：，优先队列，其内部支持按照一定的规则对内部元素进行排序。</p><p>Deque:   双端队列 既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取</p><p>实现类ArrayDeque、LinkedList</p><h2 id="Set-单例集合、无序、元素不可重复"><a href="#Set-单例集合、无序、元素不可重复" class="headerlink" title="Set 单例集合、无序、元素不可重复"></a>Set 单例集合、无序、元素不可重复</h2><p>HashSet：基于HashMap实现，底层使用HashMap来存储元素</p><p>LinkedHashSet：LinkedHashSet继承与HashSet，底层是通过LinkedHashMap实现的。</p><p>TreeSet：有序，唯一，底层是红黑树（自平衡的排序二叉数）</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="JDK1-7底层实现：-数组-链表"><a href="#JDK1-7底层实现：-数组-链表" class="headerlink" title="JDK1.7底层实现： 数组+链表"></a>JDK1.7底层实现： 数组+链表</h3><p>链表 头插法 向下移动  容量乘以加载因子就是阈值，头插法不会遍历所有的链表，找到直接返回，尾插得遍历所有</p><p>扩容：扩容原来的2倍，将旧的数组转移到先的数组中 ，在扩容的时候有可能会出现死循环死链，扩容的时候用的是头插法，导致数据的顺序发生了变化，最终出现这种情况。扩容是为了链表的长度减少，可以提高查询get的效率</p><p>fash-fail快速失败机制：在遍历元素的时候，该hashmap本来就是线程不安全的，还要进行一个元素的删除，就会发生并发的问题</p><h3 id="JDK1-8HashMap底层实现-数组-链表或红黑树"><a href="#JDK1-8HashMap底层实现-数组-链表或红黑树" class="headerlink" title="JDK1.8HashMap底层实现: 数组+链表或红黑树"></a>JDK1.8HashMap底层实现: 数组+链表或红黑树</h3><p>首先hashMap先从它的底层结构开始说它的底层结构在1.7和1.8版本是有点不一样的，它在1.7的时候底层数据结构是一个数组加上一个单链表，到1.8的时候它就改成了数组加上单链表或者说是一个红黑树的方式.当单链表和红黑树之间的转换，它的单链表的长度大于等于8并且它的hash桶大于等于64的时候，它会将单链表转换为红黑树形式存储，它的红黑树接节点的数量如果是小于等于6的时候，它会重新再转换成一个单链表，这是它底层结构的一个变化，另外关于它hash桶的数量，它的数量默认是16个，它的阈值默认是0.75也就是加载因子.这个还关系到它的扩容！</p><h3 id="HashMap扩容问题"><a href="#HashMap扩容问题" class="headerlink" title="HashMap扩容问题"></a>HashMap扩容问题</h3><p>扩容的时候它是首先会检测数组里元素个数，因为你有一个负载因子的默认值是0.75，它含有的桶数默认是16，它的阈值是16*0.75=12，当它哈希桶占用的容量大于12的时候，它就会触发扩容，它会扩容成之间哈希桶容量的二倍，它会同乘2的N次幂，它会把之前那些元素在进行一次哈希运算，然后填充到新的哈希桶里面，然后按照链表或者红黑树的方式再排列起来.它是这么一个扩容机制.</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>加锁：在同时进行put的时候，hash算法之后位置不同想同时插入的情况下，在第一个属性进行put的时候，第二个属性不能同时进行put进去，必须等待第一个put成功之后才可以，</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7底层实现"><a href="#JDK1-7底层实现" class="headerlink" title="JDK1.7底层实现"></a>JDK1.7底层实现</h3><p>底层结构是数组+链表，机制：采用了分段锁的机制，实现并发操作的更新。其中包含两个重要的核心内部类Segment和HashEntry。</p><p>Segment继承于ReentrantLock用来充当锁的角色，每一个segment锁维护着散列映射表的若干个hash桶（这里的桶指的是链表）。HashEntry用来封装映射表的键值对。</p><h3 id="JDK1-8底层实现"><a href="#JDK1-8底层实现" class="headerlink" title="JDK1.8底层实现"></a>JDK1.8底层实现</h3><p>底层结构是数组+链表或红黑树，机制：抛弃了Segment分段加锁，利用CAS+Synchronized来保证并发更新的安全。</p><p>CAS：比较并交换，在并发不是特别大的情况下，修改它需要先去查这个值，查询出来之后，进行修改，将修改的值进行写入的时候，比较之前查出来结果和原理有没有区别，如果没有区别就是安全的，如果有区别就不是安全的，不是使用直接加锁的方式，在低并发的情况下比较好。</p><p>在大量高并发的情况下缺陷：CAS底层使用了自旋锁，对cpu的消耗还是比较大的，有可能会发生ABA的问题，就是在我第一次读和再读的时候，中间可能被第三个修改并且把这个值改回去了，这个问题可以使用AtomicStampedReference来进行加版本号解决。</p><p>Synchronized：可以用在同步代码块，作用在方法之上的时候，他锁的就是this，如果是静态方法锁的就是它的class对象，Syschronized在jdk1.6之后升级还是很大的，首先是无状态的锁（就是不加锁），到偏向锁，再到轻量级锁，最后到重量级锁。</p><p>1.一般在偏向锁的情况，它就偏向于获得第一个锁的的线程，将这个线程拉到这个锁对象的对象头中，当有其他的线程过来的时候，会立刻结束这个偏向状态。</p><p>2.进而升级成一个轻量级锁，轻量级锁的消失源于虚拟机栈中开辟了一个空间叫Lock Record，将锁对象的Make word写入，尝试将另一个Lock Record 的指针，使用CAS去修改锁对象头的区域，完成一个加锁的过程，他普遍适用于一个低并发的情况，如果锁竞争较激烈的话，会立刻升级为一个重量级锁。</p><p>3.重量锁的话用的是一个互斥的过程，通过对象内部的监视器monitor实现，其中monitor的本质是依赖底层系统的mutex Lock实现，操作系统实现线程之间切换要从用户态切换至内核态，因为同步方法和同步代码块不一样。</p><p> 同步代码块：在编译之后，在代码块的前后会加上两个指令，一个是mointerenter，一个是mointerexit，一个线程过来的时候，它发现它的锁标志是无锁状态，01状态，它会尝试给一个互斥锁对象，对象会跟另一个对象进行关联，就是监视器monitor，会在monitor的一个锁定器加1，并且将monitor的指针写到对象头中表示，并且修改它的锁对象标志位为1 0，就是它的重量级锁的一个标志位，以此完成换锁的过程，并且这个过程是可重入的，因为它每次不会因为出去再进来加锁和释放锁，它每次获取这个锁，让锁记录+1即可，它加完锁之后，当其他的线程过来会检查这个锁对象头中，monitor监视器锁上计数器不为0，它会在monitor监视状态下等待去竞争这个锁，如果之前的操作结束，它就退出开始释放这锁，并且逐步的将加上的锁定释放几次，将计数器清零来完成对锁的一个释放.让其他线程继续去竞争这个锁，这是它重量级锁同步代码块的一个原理。</p><p>同步方法：而是ACC_SYNCHRONIZED标志位，相当于一个flag，当JVM去检测到这样一个flag，它自动去走了一个同步方法调用的策略，这个原理是比较简单的！锁降级基本上就是进入gc的时候了，所以基本不考虑锁降级。</p><h3 id="ReentrantLock重入锁"><a href="#ReentrantLock重入锁" class="headerlink" title="ReentrantLock重入锁"></a>ReentrantLock重入锁</h3><p>首先从JVM层面synchronized是JVM的一个关键字，ReentrantLock其实就是一个类，你需要去手动去编码，synchronized在使用的时候比较简单，直接同步代码块或者直接同步方法，我不需要关心锁的释放，但是ReentrantLock我需要手动的去lock然后配合try finally代码块一定要去把它的锁给释放，另外就是ReentrantLock相比synchronized有几个高级特性，它提供了一个，如果一个线程长期等待不到一个锁的时候，为了防止死锁，可以去手动调用lockInterruptibly方法，尝试去释放这个锁。释放自己的资源不去等待，ReentrantLock提供了一个，可以构造公平锁的一个方式，因为它的构造函数有一个但是不推荐使用，因为它会让ReentrantLock等级下降，它提供了一个condition，可以指定去唤醒绑定到condition身上的线程，来实现选择性通知的一个机制，这是它们之间的一个区别，关于选择性，如果你不需要ReentrantLock的特性的话，还是使用synchronized，因为相比来说synchronized的话，它是JVM层面的关键字，当优化JDK的时候它会非常方便的去了解，当前的锁被那些线程所持有，这个状态的话不是ReentrantLock能相比的，还是synchronized比较好些.</p><p>需要看的问题volatile关键字</p><p>ConcurrentHashMap第一次put操作</p><p>ConcurrentHashMap在构造函数中只会初始化sizeCtl值（默认为0，用来控制table的初始化和扩容操作）</p><p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以 执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线 程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</p><p>put操作</p><p>1.先通过key的hash值计算出，node节点所在的位置</p><p>2.如果相对应位置的node还未初始化是空的，则通过CAS自旋插入相应的数据。</p><p>3.如果相对位置的node不为空，move的值为-1代表正在扩容，需要同时进行扩容</p><p>如果fn对于=0就是链表</p><p>如果是TreeBin就是红黑树</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/02/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/02/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>redis是单线程的！Redis基于内存操作的，cpu不是redis的瓶颈，redis是根据机器的内存和网络带宽。</p><h3 id="redis为什么使用单线程还那么快？"><a href="#redis为什么使用单线程还那么快？" class="headerlink" title="redis为什么使用单线程还那么快？"></a>redis为什么使用单线程还那么快？</h3><p>redis是c语言写的，每秒10w+的QPS，完全不比memecache差！</p><p>核心：redis是将所有的数据全部放到内存中，所以说单线程去操作效率是最高的，多线程（CPU上下文的切换，耗时的操作）。对于内存系统来说，没有上下文的切换效率是最高的。多次读写都是在一个cpu上的，这个是最佳的方案。</p><p>redis默认有16的数据库。</p><h3 id="常见的五大数据类型"><a href="#常见的五大数据类型" class="headerlink" title="常见的五大数据类型"></a>常见的五大数据类型</h3><p>Redis-key</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">flushdb 删除数据库所有的key</span><br><span class="line"></span><br><span class="line">keys * 查看所有的key</span><br><span class="line"></span><br><span class="line">set key value </span><br><span class="line"></span><br><span class="line">EXISTS判断当前的key值是否存在 </span><br><span class="line"></span><br><span class="line">move name 1 移除当前的key</span><br><span class="line"></span><br><span class="line">EXPIER name 10 设置key的过期时间</span><br><span class="line"></span><br><span class="line">ttl name 查看当前key的剩余时间</span><br><span class="line"></span><br><span class="line">type name 查看当前的数据是什么类型</span><br><span class="line"></span><br><span class="line">incr key 每次加一</span><br><span class="line"></span><br><span class="line">decr key 每次减一</span><br><span class="line"></span><br><span class="line">getrange key 0 3截取字符串 0 -1 截取所有字符串</span><br><span class="line"></span><br><span class="line">setrange key 1 xx 替换指定位置开始的字符串</span><br><span class="line"></span><br><span class="line">步长  incrby key 指定步长</span><br><span class="line"></span><br><span class="line">步减 decrby key 指定步减</span><br><span class="line"></span><br><span class="line">setex 设置过期时间</span><br><span class="line"></span><br><span class="line">setnx  不存在设置（一般在分布锁中使用）</span><br><span class="line"></span><br><span class="line">mset k1 v1 k2 v2同时设置多个值</span><br><span class="line"></span><br><span class="line">mget同时获取多个值</span><br><span class="line"></span><br><span class="line">#对象</span><br><span class="line">mset user:1:name zhangsan user:1:age 15</span><br><span class="line">mget user:1:age user:1:name</span><br><span class="line"></span><br><span class="line">getset 先get后set</span><br><span class="line"></span><br><span class="line">getset db redis  如果不存在值，则返回nil</span><br><span class="line"></span><br><span class="line">getset db redis  如果存在值，获取原来的值，并且设置新的值</span><br><span class="line"></span><br><span class="line">msetnx  k2 v2 k3 v3 原子性操作</span><br><span class="line"></span><br><span class="line">作用：数据库、缓存、消息中间件</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在redis里边我们可以把玩成 栈、队列、阻塞队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">List的的命令都是L开头的</span><br><span class="line"></span><br><span class="line">LRANGE list  0-1 查询全部的元素</span><br><span class="line"></span><br><span class="line">LPUST LIST value (将一个值或多个值插入List列表的头部，左边)</span><br><span class="line"></span><br><span class="line">RPUST LIST value (将一个值或多个值插入List列表的头部，右边)</span><br><span class="line"></span><br><span class="line">LPUST LIST 0 -1 (查询当前list集合里边所有的值)</span><br><span class="line"></span><br><span class="line">移除元素</span><br><span class="line"></span><br><span class="line">POPL：移除左边的第一个元素 POPL LIST </span><br><span class="line"></span><br><span class="line">POPR：移除右边的第一个元素POPR LIST</span><br><span class="line"></span><br><span class="line">Lindex list 0 通过下标获取list中的一个值</span><br><span class="line"></span><br><span class="line">Llen 查询当前list的长度</span><br><span class="line"></span><br><span class="line">Lrem list 1移除几个 three值</span><br><span class="line"></span><br><span class="line">trim截断：截取数据 trim list 1 2 （index位置）</span><br><span class="line"></span><br><span class="line">rpoplpush 移除列表的最后一个元素到新的集合中rpoplpush  list otherlist</span><br><span class="line"></span><br><span class="line">lset list 0 value set的时候必须先存在下标，不然会报错，相当于替换值（替换值）</span><br><span class="line"></span><br><span class="line">lset  list 1 other 如果不存在则会报错</span><br><span class="line"></span><br><span class="line">将某个具体的value插入到某个元素的前边或者后面</span><br><span class="line">Linsert list after/before &quot;往什么字段前边插什么值&quot; &quot;插入值的内容&quot;</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">他实际上是一个链表，before node after ，left，right都插入值</span><br><span class="line">如果key不存在，创建新的链表</span><br><span class="line">如果key存在，新增内容</span><br><span class="line">移除所有值，新增内容</span><br><span class="line">如果移除了所有值，空链表，也代表不存在</span><br><span class="line">在两边插入或者改动值，效率最高！中间元素，相对效率低一点</span><br><span class="line">消息队列</span><br></pre></td></tr></table></figure><p>Set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sadd set hello (set集合中添加元素)</span><br><span class="line"></span><br><span class="line">smbmbers (查看指定set的所有值)</span><br><span class="line"></span><br><span class="line">sismember set hell (判断某一个值是不是在set中，存在返回1，不存在返回0)</span><br><span class="line"></span><br><span class="line">scard set （获取集合中的内容元素个数）</span><br><span class="line"></span><br><span class="line">srem set &quot;要移除的数据&quot;  （移除元素）</span><br><span class="line"></span><br><span class="line">set无序抽随机</span><br><span class="line"></span><br><span class="line">srandmember set （随机一个set的集合里边的元素）</span><br><span class="line"></span><br><span class="line">spop set （随机移除一个元素）出栈</span><br><span class="line"></span><br><span class="line">smove 集合1 集合2（目标） （将某个集合的元素移动到某个目标的集合）</span><br><span class="line"></span><br><span class="line">差集</span><br><span class="line"></span><br><span class="line">sdiff key1 key2 (找出key1集合和k2集合中的差集)</span><br><span class="line"></span><br><span class="line">sinter key1 key2 （找出key1集合key2集合中的交集）</span><br><span class="line"></span><br><span class="line">sunion key1 key2 （找出key1集合和key2集合中的并集）</span><br><span class="line"></span><br><span class="line">共同的粉丝数可以选用并集</span><br></pre></td></tr></table></figure><p>Hash哈希</p><pre><code>     -Map集合 key-map（value是一个map），和本质的string没有太大的区别</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hset mymap field1 zhangsan （set一个具体的key value）</span><br><span class="line"></span><br><span class="line">hget mymap field1 （获取一个字段值）</span><br><span class="line"></span><br><span class="line">hmset mymap field2 wangwu field3 zhaosi （set多个 key-value）</span><br><span class="line"></span><br><span class="line">hmget mymap field1 field2 field3 （获取多个字段值）</span><br><span class="line"></span><br><span class="line">hgetall mymap （获取全部的数据）</span><br><span class="line"></span><br><span class="line">hdel mymap field1 (删除集合中的keyfield1)</span><br><span class="line"></span><br><span class="line">hlen mymap （查看当前hash字段的长度）</span><br><span class="line"></span><br><span class="line">HEXISTS mymap field1 （判断这个hash的key值，是否在集合中存在，存在返回1，不存在返回0）</span><br><span class="line"></span><br><span class="line">hkeys mymap （可以看到当前hash所有的key值）</span><br><span class="line"></span><br><span class="line">hvalsmymap （可以看到当前hash所有的value值）</span><br><span class="line"></span><br><span class="line">hincrby mymap field1 1 (可以将hash的key值进行自增)</span><br><span class="line"></span><br><span class="line">hsetnx mymap field1 hello (判断当前hash是否存在key，不存在则添加，存在则失败)</span><br><span class="line"></span><br><span class="line">hash适合存储对象，String更适合字符串的存储 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Zset（有序集合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zrange myset 0 -1（查看zset中所有的元素）</span><br><span class="line"></span><br><span class="line">zadd myset 0 one</span><br><span class="line"></span><br><span class="line">zadd myset 1 two 0、1可以进行排序的关键字段</span><br><span class="line"></span><br><span class="line">zrangebyscore myset -inf +inf  进行排序，无穷小与无穷大</span><br><span class="line"></span><br><span class="line">zrem myset two 移除元素two</span><br><span class="line"></span><br><span class="line">zcard myset 获取集合元素的个数</span><br><span class="line"></span><br><span class="line">zrevrange mset 0 -1 withscores 倒序排序</span><br><span class="line"></span><br><span class="line">zcount myset 1 3计算当前集合区间有多少个元素 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三种特殊类型："><a href="#三种特殊类型：" class="headerlink" title="三种特殊类型："></a>三种特殊类型：</h3><h3 id="geospatial-地理位置空间"><a href="#geospatial-地理位置空间" class="headerlink" title="geospatial 地理位置空间"></a>geospatial 地理位置空间</h3><p>地理位置，朋友之间的距离</p><h3 id="范围查询hyperloglog"><a href="#范围查询hyperloglog" class="headerlink" title="范围查询hyperloglog"></a>范围查询hyperloglog</h3><p>什么是基数？</p><p>不重复的元素</p><p>简介场景？</p><p>网站UV，可以进行统计网站访问的人数，并且占用的内存非常的小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PFadd mykey a b c d e f g 创建一组数</span><br><span class="line"></span><br><span class="line">PFMERGE mykey3 mykey mykey2 并集合并两组数</span><br><span class="line"></span><br><span class="line">PFcount mykey3 查看并集数量</span><br></pre></td></tr></table></figure><h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p>位存储</p><p>统计用户信息：用来记录打卡</p><h3 id="Redis的基本事物操作"><a href="#Redis的基本事物操作" class="headerlink" title="Redis的基本事物操作"></a>Redis的基本事物操作</h3><p> Redis单条命令是原子性的，但是事物是不保证原子性的。一个事务的命令都会被序列化，在事务执行过程中，会按照顺序进行执行。</p><p>一次性、顺序性、排他性  </p><p>所有的命令在事物中，并没有直接执行。只有发起命令的时候才回去执行。exec命令</p><p>事物的本质是：一组命令的集合. 队列 set set set  执行</p><p>redis的事务</p><p>（1）开启事务 (multi)</p><p>（2）命令入队 (…) </p><p>（3）执行事物 (exec)</p><p>​    锁：redis可以执行乐观锁</p><p>放弃事物 DISCARD</p><p>编译型异常：输入的代码有问题，命令有错，事物中所有的命令都不会被执行。</p><p>运行时异常：在事物中存在语法错误，在执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常其他的命令是可以正常执行。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>很悲观，认为什么时候都会出现问题，无论做什么都会加锁。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>很乐观，认为什么时候也不会出现问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！</p><p>Redis监视测试    </p><p>使用watch做乐观锁的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money 监视money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set out 0</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec，执行之前另外一个线程把money的值进行了更改，这个时候就会导致事务执行失败</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">(integer) 20</span><br><span class="line">127.0.0.1:6379&gt; unwatch 1.如果发现事务失败，就先解锁</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money 2.获取最新的值，再次监视，select version</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec 3.比对监视值是否发生了变化，如果没有发生变化，就会执行成功。如果变化了就执行失败。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Springboot继承redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在springboot2.x之后，原来使用的jedis被替换成了lettuce.</span><br><span class="line"></span><br><span class="line">jedis:采用的是直连的，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis pool连接池。</span><br><span class="line"></span><br><span class="line">lettuce:采用netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程的数量，更像NIO模式。</span><br><span class="line"></span><br><span class="line">整合测试</span><br><span class="line"></span><br><span class="line">1.导入依赖</span><br><span class="line"></span><br><span class="line">2.配置连接</span><br><span class="line"></span><br><span class="line">3.测试 </span><br><span class="line"></span><br><span class="line">关于对象的保存需要先进行序列化</span><br></pre></td></tr></table></figure><p>redis的数据是保存在内存中的，断电及失。</p><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis是内存数据库，如果不将内存中的数据保存在磁盘中，那么一旦退出服务器,服务器的数据状态也会消失，Redis提供了持久化功能！</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snaoshot快照，它是恢复时将快照文件读取到内存中。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式比AOF更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失，我们默认就是RDB，一般情况不需要修改这个配置。</p><p>rdb保存的文件是dump.rdb</p><p>save 60 s 60s内修改5次key就会触发rdb</p><h3 id="RDB的触发机制"><a href="#RDB的触发机制" class="headerlink" title="RDB的触发机制"></a>RDB的触发机制</h3><p>1.save满足的情况下，会自动触发rdb规则。</p><p>2.执行flushdb命令，也会触发我们的rdb规则</p><p>3.退出redis，也会产生dump.rdb文件</p><p>如何恢复RDB文件，只需要将RDB文件放在我们redis启动目录局可以了，redis启动的时候会自动检测dump.rdb恢复其中的数据，需要存放的位置执行命令：config get dir 如果这个目录下存在dump.rdb文件，就会进行恢复。</p><p>优点：</p><p>适合大规模数据恢复</p><p>对数据的完整性要求不高</p><p>缺点：需要一定的时间间隔操作，如果redis宕机了。这个最后一次的数据就没有了</p><p>fork进程的时候，会占用一定的内容空间</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>将我们所有的命令都记录下来，history，恢复的时候把这个文件全部执行一遍！</p><p>以日志的形式来记录每个操作，将Redis执行过的所有指令记录下来（读操作不记录），只追加文件但不可以写成文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话根据日志文件的内容将指令从前到后执行一次以完成数据的恢复工作。</p><p>默认是不开启的，需要手动进行配置</p><p>如果aof的文件被破坏了，需要去手动恢复文件</p><p>优点：</p><p>1.每一次修改都同步，文件的完整性会更加好</p><p>2.每秒同步一次，可能会丢失一秒的数据</p><p>3.从不同步</p><p>缺点：</p><p>1.相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</p><p>2.aof运行效率也比rdb慢，所以我们的redis默认持久化就是rdb</p><h3 id="Redis发布和订阅"><a href="#Redis发布和订阅" class="headerlink" title="Redis发布和订阅"></a>Redis发布和订阅</h3><p>通信 队列 一般可以用来做聊天室之类的功能</p><p> subscribe liule 订阅的频道为liulei</p><p>publish liulei “hello,liulei” 发送消息到liulei频道</p><h3 id="集群环境搭建"><a href="#集群环境搭建" class="headerlink" title="集群环境搭建"></a>集群环境搭建</h3><p>主从复制:指的是将一台服务器的数据复制到其他的Redis服务器，前者称为主节点master/leader.后者称为从节点slave/follower,只能从主节点到单节点，Master为主以写为主，Slave以读为主。</p><p>主从复制的作用：</p><p>1.数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据的冗余方式</p><p>2.故障恢复：当主节点出现问题的时候，可以从节点提供服务，实现快速的故障恢复，实际是一种服务的冗余。</p><p>3.负载均衡：在主从复制的基础上，配合读写分离，可以从主节点提供写的服务，从节点提供读的服务，即在写数据的时候使用主节点，在读的时候使用从节点，这样可以分担服务器的压力，尤其是在读多写少的场景下，可以大大的提高redis服务器的并发量。</p><p>4.高可用：哨兵模式，在公司中一般使用 一主二从，主从复制是必须使用的，因为在真实的项目中不可能单机使用redis</p><p>info replication查看主从信息的命令 </p><p>主从复制原理：</p><p>Slave启动成功连接到master后会发送一个sync同步命令Master接到命令,启动后台的存盘进程,同时收集所有接收到的用于修改数据集命令,在后台进程执行完毕之后,master将传送整个数据文件到slave,并完成一次完全同步。</p><p>全量复制:而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。</p><p>增量复制: Master继续将新的所有收集到的修改命令依次传给slave,完成同步但是只要是重新连接master,一次完全同步(全量复制)将被自动执行!我们的数据一定可以在从机中看到!</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>一主二从 三哨兵</p><h3 id="Redis缓存穿透（查不到数据）和雪崩"><a href="#Redis缓存穿透（查不到数据）和雪崩" class="headerlink" title="Redis缓存穿透（查不到数据）和雪崩"></a>Redis缓存穿透（查不到数据）和雪崩</h3><p>用户去查询一个数据，发现redis内存数据库中没有，也就是没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。当用户很多的时候，缓存没有命中（秒杀），于是都去请求了持久层数据库，这会给持久层的数据库造成很大的压力，这时相当于出现了缓存穿透。</p><p>解决方案：</p><p>布隆过滤器</p><p>布隆过滤器是一种数据结构，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p>缓存空对象</p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期的时间，之后访问这个数据将会从缓存中获取，保护了后端数据源</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>概述</p><p>缓存击穿：是指一个key非常热点，在不停的扛着不并发，大并发集中对一个点进行访问，当这个key失效的瞬间，持续的大并发对应一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。</p><p>在某个key在过期的瞬间，有大量的请求并发访问，这类数据叫热点数据，由于缓存过期，会同时使用数据库来查询最新的数据，并且回写缓存，导致数据库瞬间压力过大。</p><h3 id="缓存击穿解决方案："><a href="#缓存击穿解决方案：" class="headerlink" title="缓存击穿解决方案："></a>缓存击穿解决方案：</h3><p>设置热点数据永不过期</p><p>从缓存层面来讲，没有设置过期时间，所以不会出现key过期后产生的问题。</p><p>加互斥锁</p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到分布式锁，因此对分布式锁考验很大。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩,是指在某一个时间段,缓存集中过期失效。</p><p>Redis 启机!产生雪崩的原因之一,比如在写本文的时候,马上就要到双十二零点,很快就会迎来一波抢购,这波商品时间比较集中的放入了缓存,假设缓存一个小时。那么到了凌晨一点钟的时候,这批商品的缓存就都过期了。而对这批商品的访问查询,都落到了数据库上,对于数据库而言,就会产生周期性的压力波峰。于是所有的请求都会达到存储层,存储层的调用量会暴增,造成存储层也会挂掉的情况。</p><p>其实集中过期,倒不是非常致命,比较致命的缓存雪崩,是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩,一定是在某个时间段集中创建缓存,这个时候,数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机,对数据库服务器造成的压力是不可预知的,很有可能瞬间就把数据库压垮。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h3 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h3><p>这个思想的含义是,既然redis有可能挂掉,那我多增设几台redis,这样一台挂掉之后其他的还可以继续工作,其实就是搭建的集群。</p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>这个解决方案的思想是,在缓存失效后,通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存,其他线程等待。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>数据加热的含义就是在正式部署之前,我先把可能的数据先预先访问一遍,这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key,设置不同的过期时间,让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium+phantomjs实现网页截屏</title>
      <link href="/2021/11/08/selenium+phantomjs%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E6%88%AA%E5%B1%8F/"/>
      <url>/2021/11/08/selenium+phantomjs%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E6%88%AA%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven环境"><a href="#Maven环境" class="headerlink" title="Maven环境"></a>Maven环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.codeborne&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;phantomjsdriver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">    &lt;!-- this will _always_ be behind --&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="具体实现代码"><a href="#具体实现代码" class="headerlink" title="具体实现代码"></a>具体实现代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    public GoodsScreenshotEntity detailsScreenshots(GoodsScreenshotEntity entity) &#123;</span><br><span class="line">        logger.info(&quot;截屏方法开始执行...&quot;);</span><br><span class="line">        //设置必要参数</span><br><span class="line">        DesiredCapabilities dcaps = new DesiredCapabilities();</span><br><span class="line">        //ssl证书支持</span><br><span class="line">        dcaps.setCapability(&quot;acceptSslCerts&quot;, true);</span><br><span class="line">        //截屏支持</span><br><span class="line">        dcaps.setCapability(&quot;takesScreenshot&quot;, true);</span><br><span class="line">        //css搜索支持</span><br><span class="line">        dcaps.setCapability(&quot;cssSelectorsEnabled&quot;, true);</span><br><span class="line">        //js支持</span><br><span class="line">        dcaps.setJavascriptEnabled(true);</span><br><span class="line">        //驱动支持（第二参数表明的是你的phantomjs引擎所在的路径）</span><br><span class="line">        dcaps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY, &quot;/jessica/spider/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs&quot;);//windows/linux环境下phantomjs的路径</span><br><span class="line">        //创建无界面浏览器对象</span><br><span class="line">        PhantomJSDriver driver = new PhantomJSDriver(dcaps);</span><br><span class="line">        //设置隐性等待（作用于全局）</span><br><span class="line">        driver.manage().timeouts().implicitlyWait(1, TimeUnit.SECONDS);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //打开页面</span><br><span class="line">        logger.info(&quot;截屏方法执行的url：&quot;+entity.getSource());</span><br><span class="line">        driver.get(entity.getSource());</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep( 2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">//        JavascriptExecutor js = driver;</span><br><span class="line">//        for (int i = 0; i &lt; 33; i++) &#123;</span><br><span class="line">//            js.executeScript(&quot;window.scrollBy(0,1000)&quot;);</span><br><span class="line">//            //睡眠10s等js加载完成</span><br><span class="line">//            Thread.sleep(5 * 1000);</span><br><span class="line">//        &#125;</span><br><span class="line">        //指定了OutputType.FILE做为参数传递给getScreenshotAs()方法，其含义是将截取的屏幕以文件形式返回。</span><br><span class="line">        File srcFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line">        String randomImgName = getRandomImgName(entity);</span><br><span class="line">        String objectName = entity.getMallId() + &quot;/&quot; + entity.getVersion() + &quot;/&quot; + randomImgName;</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        ByteArrayOutputStream byte1 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis = new FileInputStream(srcFile);</span><br><span class="line">            byte1 = new ByteArrayOutputStream(fis.available());</span><br><span class="line">            byte[] bytes = new byte[fis.available()];</span><br><span class="line">            int temp;</span><br><span class="line">            while ((temp = fis.read(bytes)) != -1) &#123;</span><br><span class="line">                byte1.write(bytes, 0, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            final String url = ossService.screenshotsUploud(objectName, bytes);</span><br><span class="line">            if (url != null) &#123;</span><br><span class="line">                logger.info(&quot;返回的OSS外链&quot;+url);</span><br><span class="line">                entity.setScreenshot(url);</span><br><span class="line">                entity.setState(ImageState.ok);</span><br><span class="line">                entity.setUploaded(true);</span><br><span class="line">                entity.setDisable(true);</span><br><span class="line">                long time = (System.currentTimeMillis() - start) / (1000);</span><br><span class="line">                logger.info(&quot;截屏成功并上传OSS耗时&quot; + time + &quot;秒， ：&#123;&quot; + &quot;商城ID：&quot; + entity.getMallId() + &quot;&#125;[&quot; + &quot;ID：&quot; + entity.getId() + &quot;][&quot; + &quot;外链: &quot; + url + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            entity.setState(ImageState.fail);</span><br><span class="line">            entity.setUploaded(false);</span><br><span class="line">            long time = (System.currentTimeMillis() - start) / (1000);</span><br><span class="line">            logger.info(&quot;截屏失败耗时&quot; + time + &quot;秒， ：&#123;&quot; + &quot;商城ID：&quot; + entity.getMallId() + &quot;&#125;[&quot; + &quot;ID：&quot; + entity.getId() + &quot;]&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte1.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        driver.quit();</span><br><span class="line">        return entity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="OSS上传代码块"><a href="#OSS上传代码块" class="headerlink" title="OSS上传代码块"></a>OSS上传代码块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Endpoint以杭州为例，其它Region请按实际情况填写。</span><br><span class="line">  final String endpoint =&quot;xxx&quot;;</span><br><span class="line">  // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录RAM控制台创建RAM账号。</span><br><span class="line">  final String accessKeyId =&quot;xxx&quot;;</span><br><span class="line">  final String accessKeySecret =&quot;xxx&quot;;</span><br><span class="line">  final String bucketName =&quot;xxx&quot;;</span><br><span class="line">  /**</span><br><span class="line">   * 截图上传</span><br><span class="line">   * @param objectName 上传的路径/图片名称</span><br><span class="line">   * @param bytes 上传的数据</span><br><span class="line">   * @return result 外链</span><br><span class="line">   */</span><br><span class="line">  public String screenshotsUploud(String objectName,byte[] bytes)&#123;</span><br><span class="line">      String result=null;</span><br><span class="line">      // 创建OSSClient实例。</span><br><span class="line">      OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">      ObjectMetadata obj= new ObjectMetadata();</span><br><span class="line">      obj.setContentType(&quot;image/jpg&quot;);</span><br><span class="line">      PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectName, new ByteArrayInputStream(bytes),obj);</span><br><span class="line">      ossClient.putObject(putObjectRequest);</span><br><span class="line">      Date expiration = new Date(System.currentTimeMillis() + 3600L * 1000 * 24 * 365 * 10);</span><br><span class="line">      URL url = ossClient.generatePresignedUrl(bucketName, objectName, expiration);</span><br><span class="line">      // 关闭OSSClient。</span><br><span class="line">      ossClient.shutdown();</span><br><span class="line">      return url.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向小程序</title>
      <link href="/2021/11/08/%E9%80%86%E5%90%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/11/08/%E9%80%86%E5%90%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>蓝叠安卓模拟器：为什么要用模拟器呢?因为反编译小程序的包需要用到ROOT权限所以比较方便，废话不多说开整。</p><p>反编译工具：wxappUnpacker</p><p>ES文件管理器：用来寻找小程序的包</p><p>环境:node.js</p><p>在进行反编译小程序之前要搞清楚它的原理，首先使用安卓模拟器打开微信小程序之后，就会自动下载小程序的包，默认格式为wxapkg为后缀的文件，进入 /data/data/com.tencent.mm/MicroMsg/{数串}/appbrand/pkg/**这个目录下就可以看到，可以根据时间来判断哪个是你刚打开的小程序的包。</p><p><img src="/images/%E9%80%86%E5%90%91%E5%B0%8F%E7%A8%8B%E5%BA%8F1-2.png" alt="image-20211108210524903"></p><h2 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h2><p>1.打开安卓模拟器，下载微信、qq、ES文件管理器</p><p>2.打开你想要反编译的小程序</p><p>3.去这个目录/data/data/com.tencent.mm/MicroMsg/{数串}/appbrand/pkg/**找到要反编译的包，将包压缩成文件，通过qq文件传输到自己的电脑。</p><p>4.打开wxappUnpacker文件夹，cmd到当前文件夹执行以下命令</p><h3 id="第一步安装依赖包"><a href="#第一步安装依赖包" class="headerlink" title="第一步安装依赖包"></a>第一步安装依赖包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">npm install css-tree</span><br><span class="line">npm install cssbeautify</span><br><span class="line">npm install vm2</span><br><span class="line">npm install uglify-es</span><br><span class="line">npm install js-beautify</span><br></pre></td></tr></table></figure><h3 id="第二步执行反编译操作命令"><a href="#第二步执行反编译操作命令" class="headerlink" title="第二步执行反编译操作命令"></a>第二步执行反编译操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js D:\wxappUnpacker\_-1618246301_29.wxapkg</span><br></pre></td></tr></table></figure><p>执行成功的效果如下图：</p><p><img src="/images/%E9%80%86%E5%90%91%E5%B0%8F%E7%A8%8B%E5%BA%8F1-1.png" alt="image-20211108210453308"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>成功之后使用微信开发者工具直接打开文件夹即可，接下来就可以看到你想的东西就可以尽情的奔放了。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT常用命令</title>
      <link href="/2021/11/07/GIT%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/07/GIT%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h2><p>本地库初始化，命令：git add</p><p>隐藏的文件查看命令：ls -lA</p><p>查看工作区和暂存区的状态：git states</p><p>将工作区的 新建或修改 的文件提交到暂存区：git add File文件名</p><p>将暂存区中的文件删除：git rm –cached 文件名</p><p>将暂存区的文件提交到本地库：git commit 文件名  || git commit  -m  “第一次提交” 文件名</p><p>总结:第一次提交文件需要先执行git add 文件名进行文件的追踪，如果更改文件内容后进行提交，add操作可执</p><p>行或也可不执行直接进行commit操作</p><h2 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h2><p>git remote  -v 查看远程仓库地址是否有别名</p><p>git remote add  仓库地址或者别名 </p><p>git push origin master 推送到分支</p><h2 id="ssh免密公私钥生成"><a href="#ssh免密公私钥生成" class="headerlink" title="ssh免密公私钥生成"></a>ssh免密公私钥生成</h2><p>ssh -keygen -t rsa -C <a href="mailto:&#x31;&#x31;&#48;&#51;&#x30;&#49;&#x31;&#x30;&#51;&#x33;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x31;&#x31;&#48;&#51;&#x30;&#49;&#x31;&#x30;&#51;&#x33;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a> 生成公钥私钥</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
