<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="" />
  <meta name="description" content="" />
  
  
  <title>
    
      JVM 
      
      
      |
    
     Welcome!MyBlog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>

</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">记录点滴足迹 留下美好时光</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">朋友</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">JVM</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2023-09-10 21:22:05
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="Java面试总结">
                    <b>#</b> Java面试总结
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h3 id="JVM的组成部分？"><a href="#JVM的组成部分？" class="headerlink" title="JVM的组成部分？"></a>JVM的组成部分？</h3><h5 id="类加载器子系统ClassLoader"><a href="#类加载器子系统ClassLoader" class="headerlink" title="类加载器子系统ClassLoader"></a>类加载器子系统ClassLoader</h5><p>作用：负责从文件系统或网络中加载Class文件，class文件在文件开头有特定的文件标识；</p>
<p>​            ClassLoader只负责class文件的加载，运行由Execution Engine决定；</p>
<p>​            加载类信息存放于方法区的内存空间。方法区除了类信息，还会存放运行时常量池，还可能包含字符串字面量和数字常量；</p>
<p>类加载的生命周期：加载→链接（验证、准备、解析）→初始化→使用→卸载</p>
<p>加载loading：JVM对class对象是按需加载，加载到内存生成class对象，采用双亲委派模型加载</p>
<p>1.通过类的全限定类名获取到此类的二进制字节流</p>
<p>2.将这个字节流所代表的静态存储结构转化为方法区运行时数据结构</p>
<p>3.在内存中生成一个代表这个类的大Class对象，作为方法区这个类的各种数据入口</p>
<p>链接Linking：验证-准备-解析</p>
<p>验证：文件格式验证、元数据验证、字节码验证、符号引用验证</p>
<p>准备：为类的变量分配 内存并且设置该类的默认初始值（不包含final修饰的static，因为final在编译的时候就会分配，也不会给实例变量初始化）</p>
<p>解析：将常量池内的符号引用转换为引用的过程</p>
<p>初始化initialization</p>
<p>为类的静态变量进行赋予正确的值</p>
<p>插件：bytecode viewer、jclasslib bytecode viewer</p>
<p>可以可视化已编译Java类文件和所包含的字节码的工具。 另外，它还提供一个库，可以让开发人员读写Java类文件和字节码。</p>
<p>类加载器的分类？</p>
<p>引导类加载器（Bootstrap ClassLoader）：使用c++实现的，系统的核心类库都是使用引导类加载器加载的</p>
<p>扩展类加载器（Extension ClassLoader）：获取上层记载器是空</p>
<p>系统类加载器（System ClassLoader）:获取其上层加载器是扩展类加载器，定定义的类是系统类加载器加载的</p>
<p>自定义类加载器（User-Defined ClassLoader）</p>
<h6 id="双亲委派机制？"><a href="#双亲委派机制？" class="headerlink" title="双亲委派机制？"></a>双亲委派机制？</h6><p>Java虚拟机对class采用的是按需加载，也就是说当需要使用该 类的时候才会将class文件加载到内存生成class对象，而加载类的时候，java虚拟机使用的是双亲委派模式，就是把请求都交给父类类处理，是一种委派模式。</p>
<p>工作原理：</p>
<p>如果一个类加载器收到了加载请求，他不会自己去加载，而是委托给父类的加载器是执行。</p>
<p>如果父类加载器还存在其父类加载器，则向上委托，依次递归</p>
<p>如果父类加载器完成类的加载任务，就成功。如果父类加载器无法此任务，子加载器会尝试自己加载。</p>
<p>优势：</p>
<p>避免类的重复加载</p>
<p>防止核心的API被随意篡改</p>
<p>沙箱安全机制：保证源代码的保护</p>
<h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><h5 id="程序计数器-PC-Register"><a href="#程序计数器-PC-Register" class="headerlink" title="程序计数器(PC Register)"></a>程序计数器(PC Register)</h5><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<ul>
<li>作用:存储指向下一条指令的地址代码，由执行引擎读取下一条指令（偏移地址 ）。</li>
<li>特点：<ul>
<li>线程是私有的，独有一份</li>
<li>不会存在内存溢出</li>
</ul>
</li>
</ul>
<p>使用PC寄存器存储字节码指令地址有什么用呢？</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来，就得知道接着从哪执行 </p>
<p>PC寄存器为什么设定为私有的？</p>
<p>一个cpu核执行多个线程，线程进行一个切换，每个线程切换之后会记录自己的地址值，执行到了哪一步</p>
<h5 id="栈（Stacks）"><a href="#栈（Stacks）" class="headerlink" title="栈（Stacks）"></a>栈（Stacks）</h5><ul>
<li><p>栈：每个线程运行都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的Java方法调用，是线程私有的</p>
</li>
<li><p>栈帧：每个方法运行时需要的内存（局部变量（基础数据类型、对象的引用地址），参数，返回地址），每个栈由多个栈帧组成，对应着每次方法调用所占用的内存</p>
</li>
<li><p>每个线程只能一个活动栈帧，对应着正在执行的那个方法</p>
</li>
<li><p>特点：</p>
<ul>
<li>先进后出</li>
</ul>
</li>
<li><p>问题？</p>
</li>
<li><p>垃圾回收是否涉及栈内存？</p>
<p>不会涉及，因为在每个方法执行结束之后，自动会出栈，无需进行垃圾回收处理，只有堆内存的对象才需要进行垃圾回收管理。</p>
</li>
<li><p>栈内存分配越大越好吗？</p>
<p>不会，如果栈内存分配的越大，线程数会变小，因为我们的物理内存是一定的，分配的越大线程数则会变小，从而影响我们的运行速度，栈内存分配不是越大越好，它分配大了只是能够进行多次方法的递归调用，而不会增快程序的运行效率，反而会影响线程数目的变小。一般采用默认就可以，不必在程序启动的时候手动修改。</p>
</li>
<li><p>方法内的局部变量是否是线程安全？</p>
<p>当方法内局部变量没有逃离方法的作用访问时线程安全，因为一个线程对应一个栈，每调用一个方法就会产生一个栈帧，都是线程私有的局部变量，当变量是static时则不安全，因为是线程共享的。</p>
<p>如果局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全。</p>
<ul>
<li>栈内存溢出？</li>
</ul>
<p>栈帧过多导致内存溢出（递归调用）</p>
<p>栈帧内存过大导致内存溢出</p>
<p>循环引用  </p>
</li>
<li><p>线程诊断</p>
<p>用top命令定位哪个进程对cpu占用过高。命令：ps H -eo pid,tid,%cpu|grep 进程id</p>
<p>jstack 进程id 可以根据线程id找到 ，进一步定位到问题代码的源码行号</p>
</li>
<li><p>运行很长时间没有找到结果</p>
</li>
</ul>
<h6 id="栈运行原理？"><a href="#栈运行原理？" class="headerlink" title="栈运行原理？"></a>栈运行原理？</h6><p>JVM对java栈的操作只有压栈、出栈，在一条活动线程中，一个时间点，只会有一个活动的栈帧，只有当前在执行的方法的栈帧是有效的，称为当前栈帧，与当前栈帧对应的方法是当前方法，定义这个方法的类就是当前类。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈。</p>
<p>如果当前方法调用了其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机丢弃当前栈帧，使得前一个栈帧成为当前栈帧</p>
<p>Java方法有两种返回函数的方式：一种是正常的函数返回，使用return指令；另外一种是抛出异常。这两种方式都会栈帧被弹出</p>
<h6 id="栈帧的内部结构？"><a href="#栈帧的内部结构？" class="headerlink" title="栈帧的内部结构？"></a>栈帧的内部结构？</h6><p>局部变量表：定义一个数字数组，存储方法参数和定义在方法的局部变量，这类数据包括基本数据类型、对应引用、返回类型，局部变量表所需要的容量大小是在编译期确定下来的</p>
<p>JVM中的每个Solt都分配了一个索引，通过索引就可以成功访问局部变量表中指定的局部变量值。</p>
<p>当一个实例方法被调用的时候，方法参数和方法体内定义的局部变量将会被复制到局部变量表中的每一个Slot上。</p>
<p>访问64bit的局部变量时，只需要使用前边的第一个索引即可（比如long或double的变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，该对象引用this将会放在index为0的slot处，其余的参数按照参数表继续排列</p>
<p>槽是可以重复使用的，局部变量过了其作用域，新的变量就会复用过期局部变量的槽位 </p>
<p>按照数据类型分：基本数据类型、引用数据类型</p>
<p>按照位置分：成员变量：在使用前都会进行赋默认值，类变量：在linking的prepare阶段给变量默认值，initial阶段给类变量显式赋值及                        静态代码块赋值，实例变量随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</p>
<p>​                        局部变量：在使用前，必须显示赋值！否则编译不通过</p>
<p>操作数栈（或表达式栈）：对应着每一条jvm字节码指令</p>
<p>动态链接（指向运行时常量池的方法引用）</p>
<p>常量池编译后在栈帧中的动态链接是用符号#12来显示的，当我们运行的时候，在方法区也会加载一份，栈帧中的符号指向运行时常量池的地址值</p>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
<p>方法返回地址（方法正常退出或者异常推出的定义）</p>
<p>一些附加信息</p>
<h5 id="Native-Method-Stacks-本地方法栈"><a href="#Native-Method-Stacks-本地方法栈" class="headerlink" title="Native Method Stacks 本地方法栈"></a>Native Method Stacks 本地方法栈</h5><p>调用其他编程语言编写的底层代码</p>
<h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h5><h6 id="堆的概述注意点"><a href="#堆的概述注意点" class="headerlink" title="堆的概述注意点"></a>堆的概述注意点</h6><p>一个JVM实例只存在一个堆内存，堆内存在JVM启动的时候就被创建，其空间大小也确定了，堆内存的空间大小是可以调节的。</p>
<p>堆可以处于物理上不连续的内存空间中，但是在逻辑上是连续的（栈帧和堆形成映射表，栈帧是连续入栈，所以在方法执行的时候相当于是有续的）。</p>
<p>所以的线程共享堆，在堆里还能划分线程私有的缓冲区（ThredLocal Allocation Buffer，TLAB）</p>
<p>几乎所有的对象实例都在堆分配内存。(<em>逃逸分析利用标量替换实现堆上的对象分解为栈上的标量</em>)</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧保存引用，引用指向对象或数组在堆中的位置。</p>
<p>在整个方法结束后，堆中的对象不会马上被移除，仅仅是在垃圾回收的时候才会被回收。</p>
<p>通过new关键字，创建对象都会使用堆内存</p>
<h6 id="JDK7和JDK8的变化"><a href="#JDK7和JDK8的变化" class="headerlink" title="JDK7和JDK8的变化"></a>JDK7和JDK8的变化</h6><ul>
<li><p>JDK8之后元空间取代了永久代，JDK8没有了PermSize相关的参数配置：XX:PermSize 和 -XX:MaxPermSize 已经失效。</p>
</li>
<li><p>元空间使用本地内存（系统内存），永久代使用虚拟机堆中内存。</p>
</li>
<li><p>JDK1.6及之前：有永久代，静态变量存放在永久代上</p>
</li>
<li><p>JDK1.7：有永久代，但逐步移除永久代，字符串常量池、静态变量移除，保存在堆中</p>
</li>
<li><p>JDK1.8：无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆中</p>
</li>
<li><p>stringtable调整的原因是永久代回收效率低，在full gc的时候才会触发，而full gc是老年空间的不足、永久代不足时才会触发，导致StringTable回收效率不高，在正常的开发中，我们会创建大量的字符串，回收效率低会导致永久代内存不足，放到堆里可以及时回收。</p>
</li>
</ul>
<h6 id="设置堆空间的内存大小"><a href="#设置堆空间的内存大小" class="headerlink" title="设置堆空间的内存大小"></a>设置堆空间的内存大小</h6><p>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小（X 是jvm的运行参数， ms 是memory start）</p>
<p>-Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</p>
<p>默认堆空间的大小</p>
<p>初始内存大小：物理电脑内存大小 / 64</p>
<p>最大内存大小：物理电脑内存大小 / 4</p>
<p>手动设置：-Xms600m -Xmx600m（开发中建议将初始堆内存和最大的堆内存设置成相同的值。）</p>
<ul>
<li><p>特点</p>
<p>它是线程共享的，堆中对象都需要考虑线程安全的问题</p>
<p>有垃圾回收机制</p>
</li>
<li><p>堆内存诊断工具 </p>
<p>jps工具：查看当前系统有哪些java进程（jps   /  jstat -gc 进程id）</p>
<p>方式二：设置-XX:+PrintGCDetails参数可以在控制台打印</p>
<p>jmap工具：查看堆内存占用情况</p>
<p>jconsole工具：图像界面，多功能的监测工具，可以连续监测        </p>
</li>
</ul>
<h6 id="堆空间中的年轻代与老年代"><a href="#堆空间中的年轻代与老年代" class="headerlink" title="堆空间中的年轻代与老年代"></a>堆空间中的年轻代与老年代</h6><p>JAVA堆区可以进一步划分为年轻代（YoungGen）和老年代（ OldGen），其中年轻代可以划分为Eden空间（伊甸园）、Survivor0空间和Survivor1空间（有时候也叫from区、to区）</p>
<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>如果修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
<li>启动参数： -Xms600m -Xmx600m -XX:+UseAdaptiveSizePolicy（打开自适应的内存分配策略）</li>
<li>启动参数： -Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy（关闭自适应的内存分配策略）</li>
<li>启动参数： -Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy（关闭自适应的内存分配策略）</li>
</ul>
<h6 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h6><p>1.new的对象先放到伊甸园区。大小对象的区分：如果是大对象，直接出发gc分配到老年区（尽量避免程序中出现过多的大对象）</p>
<p>2.当伊甸园区空间填满之后，程序又要创建对象，JVM的垃圾回收器将对伊甸园区和存活区进行垃圾回收（Minor Gc）,将不再被其他对象引用的对象进行销毁，然后将伊甸园中剩余的对象移动到幸存者TO区，再将新的对象放到伊甸园区。</p>
<p>3.如果伊甸园再次触发gc的话，将上次TO区的对象并且包含本次垃圾回收后的幸存者存入TO区。（针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to区.）</p>
<p>4.移动到To区的对象年龄每次+1，年龄超过15晋升为老年区，默认为15次。可以设置参数: -XX:MaxTenuringThreshold=N次 进行设置。</p>
<p>5.当老年区内存不足时，再次触发GC: Major GC, 进行养老区的内存清理。</p>
<p>6.若老年区执行了Major GC之后还发现无法进行对象的保存，就会产生OOM异常。</p>
<p>总结：</p>
<p>针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to区.</p>
<p>关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区，元空间收集。</p>
<p>如果对象在Eden出生并经过第一次MinorGC 后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor、区中每熬过一次MinorGC ，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置。</p>
<h6 id="针对不同年龄段的对象分配原则"><a href="#针对不同年龄段的对象分配原则" class="headerlink" title="针对不同年龄段的对象分配原则"></a>针对不同年龄段的对象分配原则</h6><ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</p>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p>
<h6 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h6></li>
<li><p><em>Jconsole</em></p>
</li>
<li><p><em>VisualVM</em></p>
</li>
<li><p><em>Jprofiler</em></p>
</li>
<li><p>JDK命令行</p>
</li>
<li><p>Eclipse :Memory Analyzer Tool</p>
</li>
<li><p>Java Flight Recorder</p>
</li>
<li><p>GCViewer</p>
</li>
<li><p>GC Easy</p>
</li>
</ul>
<h6 id="三种GC区别"><a href="#三种GC区别" class="headerlink" title="三种GC区别"></a>三种GC区别</h6><p>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对HotSpotVM的实现，它里面的GC按照回收区域又分为两大种类型:</p>
<p>1.部分收集</p>
<ul>
<li><p>新生代收集(Minor GC/Young GC):只是新生代(Eden\S0,S1)的垃圾收集。</p>
<p>触发机制：当年轻代空间不足时， 就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存。)</p>
<p>​                    MinorGC非常频繁，一般回收速度也比较快。</p>
<p>​                    Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
</li>
<li><p>老年代收集(Major GC/0ld GC):只是老年代的垃圾收集。（目前，只有CMS GC会有单独收集老年代的行为。）</p>
<p>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</p>
<ul>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
</li>
<li><p>混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。（目前只有G1 GC会有这种行为）</p>
</li>
<li><p>FUll GC触发机制</p>
<p>老年代空间不足、方法区空间不足</p>
<p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
<p>由Eden区、s0区向s1区复制时，对象大小大于To区（幸存者区）可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</li>
</ul>
<p>2.整堆收集</p>
<ul>
<li>收集整个java堆和方法区的垃圾收集。</li>
</ul>
<h6 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h6><p>java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）</p>
<h6 id="堆为什么进行分代？"><a href="#堆为什么进行分代？" class="headerlink" title="堆为什么进行分代？"></a>堆为什么进行分代？</h6><p>因为对象的生命周期不同，分开好管理。</p>
<p>有利于提高垃圾回收效率，把生命周期较短的对象区域进行回收，这这也就可以腾出很大一部分的空间。</p>
<h6 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h6><ul>
<li><p>TLAB(Thread Local Allocation Buffer) 线程私有的分配缓冲区。</p>
</li>
<li><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
</li>
<li><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。提升分配效率</p>
</li>
<li><p>为什么需要TLAB</p>
</li>
<li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
</li>
</ul>
<p>逃逸分析不成熟.</p>
<h5 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h5><p>JDK1.6方法区：PermGen永久代，包含class类,ClassLoader类加载器，常量池、字符串常量池StringTable，使用的是堆空间。</p>
<p>JDK1.8元空间：PermGen永久代被废弃，方法区变为元空间，包含class类，ClassLoader类加载器，常量池，使用的是本地内存，StringTable字符串常量池是在堆中。</p>
<p>内存溢出：因为在1.8直接是用的本机pc内存非常的大，很难模仿出元空间溢出的现象，所以需要参数- XX：MaxPermSize=8m来指定他的元空间大小。</p>
<p>User user = new User();User是类型 user是引用，存放到栈帧中的  new User()是指向堆空间的一块区域</p>
<p> 方法区包含了运行时常量池：在字节码文件中有常量池Constant Pool，classLoader将字节码加载到方法区就成了运行时常量池，所以是在方法区的</p>
<p>常量池：常量池就是一张表，虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类 型、字面量等信息。二进制字节码包含（类基本信息，常量池，类方法定义，虚拟机指令）</p>
<p>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分在类加载之后存放到方法区的运行时常量池</p>
<p>运行时常量池：常量池是在.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并且把里边的符号地址变为真是的地址。</p>
<h4 id="关于对象的相关内容"><a href="#关于对象的相关内容" class="headerlink" title="关于对象的相关内容"></a>关于对象的相关内容</h4><h5 id="对象实例化步骤"><a href="#对象实例化步骤" class="headerlink" title="对象实例化步骤"></a>对象实例化步骤</h5><p>1.加载类元信息</p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。</p>
<p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p>
<p>类加载阶段：加载、链接（验证-&gt;准备-&gt;解析）、初始化</p>
<p>2.为对象分配内存</p>
<p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量（地址）空间即可，即4个字节大小。对象大小具体算。</p>
<ul>
<li><p>如果内存规整，使用指针碰撞</p>
</li>
<li><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bump The Pointer) 来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虛拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>如果内存不规整，使用空闲列表</p>
</li>
<li><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为：空闲列表(Free List)。</p>
<p>说明:选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
</li>
</ul>
<p>3.处理并发问题</p>
<p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性，创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题:</p>
<ul>
<li>CAS(Compare And Swap)失败重试、区域加锁:保证指针更新操作的原子性</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。(堆篇章已介绍)</li>
</ul>
<p>4.属性的默认初始化</p>
<p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接调用使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>5.设置对象的对象头</p>
<p>将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<p>6.属性的显示初始化、构造代码块初始化、构造器初始化（执行init方法进行初始化）</p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行构造代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespeclal指令所决定)， new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
<p>注意：</p>
<p>静态变量和静态代码块的默认初始值是在类加载阶段的链接阶段来初始化的，显式初始化赋值是在clint阶段完成的。</p>
<ol>
<li>JOT可以查询对象大小，引入如下依赖：</li>
</ol>
<dependency>    

<p>​        <groupId>org.openjdk.jol</groupId>    </p>
<p>​        <artifactId>jol-core</artifactId>    </p>
<p>​        <version>0.16</version></p>
 </dependency>

<p>对象内存的布局</p>
<p>1.对象头包含两部分：运行时元数据和类型指针</p>
<p>运行时元数据：哈希值、GC分代年龄、锁状态标准、线程持有的锁、偏向线程ID、偏向时间戳</p>
<p>类型指针：指向类元数据InstanceKlass，确定该对象的所属类型</p>
<p>2.实例数据：包括程序中定义的各种数据类型字段（包含父类继承下来的和本身的字段），规则是先放父类的变量，从父类加载开始</p>
<p>3.对其填充：占位符的作用</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存是在Java堆外的、直接向系统申请的内存区间</p>
<ul>
<li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p>
</li>
<li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p>
</li>
<li><p>也可能导致OutOfMemoryError异常</p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xnx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<p>-XX:MaxDirectMemorySize=大小：设置直接内存；如果不指定，默认与堆的最大值-Xmx参数值一致</p>
<p>缺点：分配回收成本较高、不受JVM内存回收管理</p>
<p>非直接缓存区：读写文件，需要与磁盘交互，需要由用户态切换到内核态。这里需要两份内存存储重复数据，效率低。</p>
<p>直接缓存区：使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p>
</li>
</ul>
<h5 id="StringTable-字符串常量池"><a href="#StringTable-字符串常量池" class="headerlink" title="StringTable 字符串常量池"></a>StringTable 字符串常量池</h5><p>常量池中的信息，都会被加载到运行时常量池，都是常量池中的符号，还没有变为java字符串对象，会先去串池里找，如果串池里没有就会放入到串池，如果有就会用串池的，取值对象也是唯一的</p>
<p>#2符号会把a符号变为“a”字符串对象</p>
<p>String s1 = “a”;惰性的，是一行一行记载的，相同的则不加载</p>
<p>StringTable[“a”,”b”,”ab”] 是一个hashtable结构，不能扩容</p>
<p>字符串常量是放到串池的，字符串拼接是重新new了一个新的String对象，他俩的地址值不同</p>
<h5 id="解释器-执行引擎（Execution-engine）"><a href="#解释器-执行引擎（Execution-engine）" class="headerlink" title="解释器 执行引擎（Execution engine）"></a>解释器 执行引擎（Execution engine）</h5><p>为什么说Java是半编译半解释型语言？</p>
<p>JDK1.0，将Java语言定位为“解释执行”语言，后来可以直接生成本地代码的编译器，现在JVM执行的时候，通常都会将解释和编译二者结合运行</p>
<p>热点代码及探测方式</p>
<p>解释器响应速度快，编译器运行速度快</p>
<h4 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h4><h5 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h5><p>如何判断一个对象是否存活？（当一个对象不再被任何存活的对象引用时），主要有以下两种算法：引用计数算法、可达性分析算法。</p>
<h6 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h6><p>一个对象被引用后，引用计数器+1，在没被引用时，引用计数器-1，引用计数器为0的时候，表示该对象没被引用，可以进行回收。</p>
<p>引用计数器的缺点：不能解决循环引用的问题。（对象A引用了对象B，然后对象又去引用了对象A，形成了一个循环），使用引用计数器的语言有python，解决循环引用的办法是手动解除循环引用的关系</p>
<h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>别名：根搜索算法、追踪性垃圾算法</p>
<p>优点：可以有效解决循环引用的问题，防止内存泄漏的问题</p>
<p>基本思路：</p>
<p>（1）是以根对象集合GC roots为起点，开始按照从上至下的方式搜索，被根对象集合所连接的目标对象是否可达。</p>
<p>（2）存活对象:使用该算法之后，存活的对象会被根对象集合直接或间接连接着，该路径成为引用链。</p>
<p>（3）垃圾对象:如果目标对象没有被任何引用链相连，可以标记为垃圾对象。</p>
<h5 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h5><p>JVM常见的三种垃圾收集算法是标记-清除算法、复制算法、标记-压缩算法</p>
<h6 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark - Sweep）"></a>标记-清除算法（Mark - Sweep）</h6><p>当堆中的有效空间被耗尽时，就会停止整个程序，然后进行标记-清除</p>
<p>标记：就是使用可达性分析算法从根节点进行遍历，标记所有被引用的对象，在对象的header头中记录可达对象。</p>
<p>清除：在堆内存中从头到尾进行线性的遍历，发现某个对象在header中没有标记为可达对象，则会回收。</p>
<h6 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h6><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p>复制算法是建立在存活对象少，垃圾对象对象多的前提下的，这种情况一般发生在新生代，但是在老年代大部分都是存活对象，如果依然使用复制算法，复制的对象较多，复制成本也是非常的高，需要使用其他的算法。标记清除算法的确可以使用在老年代，但是算法的执行效率低下，在执行完内存回收时还会产生碎片，所以需要进行改进，由此诞生的算法才是标记-压缩算法。</p>
<h6 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark - Compact）"></a>标记-压缩算法（Mark - Compact）</h6><p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用的对象。</p>
<p>第二阶段将所有内存对象压缩到内存的一端，按照之前存活对象之后的顺序排放（JVM只需要有一个内存的起始地址即可）， 之后清除边界外所有的空间。</p>
<p>标记-压缩最后的效果等同于标记-清除算法执行完之后，再进行一次碎片整理，也可以称之为标记-清除-压缩算法。</p>
<h5 id="System-gc的理解？"><a href="#System-gc的理解？" class="headerlink" title="System.gc的理解？"></a>System.gc的理解？</h5><p>在默认情况下，通过System.gc()实则是调用Runtime.getRuntime().gc()，会显式触发Full GC， 同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p><em>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</em></p>
<p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而-一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p>
<h5 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h5><p>内存泄漏（memory leak） :是指程序在申请内存后，无法释放已申请的内存空间（即使对象不再使用了，但是虚拟机没有释放），一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
<p>内存溢出（out of memory） :指程序申请内存时，没有足够的内存供申请者使用，并且垃圾收集器也无法提供更多内存。此时就会报错OOM,即所谓的内存溢出。</p>
<h6 id="内存泄漏案例"><a href="#内存泄漏案例" class="headerlink" title="内存泄漏案例"></a>内存泄漏案例</h6><p>单例模式：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<p>一些提供close的资源未关闭导致内存泄漏数据库连接(dataSourse.getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
<h6 id="内存溢出解决方案"><a href="#内存溢出解决方案" class="headerlink" title="内存溢出解决方案"></a>内存溢出解决方案</h6><p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数调整)</p>
<p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</p>
<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>
<p>第四步，使用内存查看工具动态查看内存使用情况</p>
<p>重点排查以下几点：</p>
<ul>
<li>1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li>
<li>2.检查代码中是否有死循环或递归调用。</li>
<li>3.检查是否有大循环重复产生新对象实体。</li>
<li>4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li>
<li>5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li>
</ul>
<h6 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h6><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<ul>
<li>开发中不要用System.gc(),会导致Stop-the-world的发生。</li>
<li>G1也不能完全避免Stop-the-world 情况发生</li>
</ul>
<h6 id="程序的并发（Concurrent）与并行（Parallel）"><a href="#程序的并发（Concurrent）与并行（Parallel）" class="headerlink" title="程序的并发（Concurrent）与并行（Parallel）"></a>程序的并发（Concurrent）与并行（Parallel）</h6><p>并发（Concurrent）：一个时间段内，且几个程序都是在同一个处理器上运行，并发不是真正意义上的同时进行，只是cpu把一个时间段划分为几个时间片段，着时间区间之间来回切换，由于cpu处理的速度非常快，只要时间间隔处理得当，感觉是多个应用程序同时在进行</p>
<p>并行（Parallel）：系统有一个以上CPU时，当一个CPU执行一个进程时，另一个cpu在执行另一个进程，连个进程不抢占CPU资源，可以称之为并行，多核也可以进行并行</p>
<p>在谈论垃圾收集器的上下文语境中，它们可以解释如下:</p>
<ul>
<li><p>并行(Parallel) :指</p>
<p>多条垃圾收集线程并行工作</p>
<p>，但此时用户线程仍处于等待状态。</p>
<ul>
<li>如ParNew、 Parallel Scavenge、 Parallel 0ld;</li>
</ul>
</li>
<li><p>串行(Serial)</p>
<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
<li><p>并发(Concurrent) :指用户线程与垃圾收集线程可能会交替执行，</p>
<ul>
<li>如: CMS、G1</li>
</ul>
</li>
</ul>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><ul>
<li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safepoint)”</li>
</ul>
<p>​        Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂,通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择一些执行时间较长的指令作为SafePoint，如方法调用、循环跳转和异常跳转等。</p>
<h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</p>
<ul>
<li>抢先式中断:(目前没有虚拟机采用了)首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li>主动式中断:设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?</p>
<p>例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<ul>
<li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint。</li>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止;</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public,可以在应用程序中直接使用</p>
<ul>
<li><code>强引用(StrongReference)</code> ：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><code>软引用(SoftReference)</code> :在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li><code>弱引用(WeakReference)</code> :被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li><code>虚引用(PhantomReference)</code> :一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h3 id="强引用-不回收"><a href="#强引用-不回收" class="headerlink" title="强引用-不回收"></a>强引用-不回收</h3><ul>
<li><em>强引用可以直接访问目标对象。</em></li>
<li><em>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿拋出OOM异常，也不会回收强引用所指向对象。</em></li>
<li><em>强引用可能导致内存泄漏。</em></li>
</ul>
<h3 id="软引用-内存不足即回收"><a href="#软引用-内存不足即回收" class="headerlink" title="软引用-内存不足即回收"></a>软引用-内存不足即回收</h3><ul>
<li><p><em>软引用是用来描述一些还有用，但非必需的对象。</em></p>
</li>
<li><p><em>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</em></p>
</li>
<li><p>软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</li>
</ul>
<h3 id="弱引用-发现即回收"><a href="#弱引用-发现即回收" class="headerlink" title="弱引用-发现即回收"></a>弱引用-发现即回收</h3><p><em>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</em></p>
<p><em>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</em></p>
<p>由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p><em>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</em> 如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<h3 id="虚引用-对象回收跟踪"><a href="#虚引用-对象回收跟踪" class="headerlink" title="虚引用-对象回收跟踪"></a>虚引用-对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p><em>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</em></p>
<p><em>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。</em> 比如:能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>终结器引用(Final reference)它用以实现对象的finalize()方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法</p>
<p>构造函数为私有，无法自己构建这类对象</p>
<p>第二次GC时才能回收被引用对象。因为只有在FinalizerThread执行完了对象的finalize方法的情况下才有可能被下次gc回收，而有可能期间已经经历过多次gc了，但是一直还没执行f对象的finalize方法</p>
<p>作者获得授权，非商业转载请注明出处。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/02/21/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2023-09-10 21:22:05
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="Java面试总结">
                        <b>#</b> Java面试总结
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/09/10/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">JVM的组成部分？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9FClassLoader"><span class="toc-number">1.0.1.</span> <span class="toc-text">类加载器子系统ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">双亲委派机制？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-PC-Register"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序计数器(PC Register)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stacks%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">栈（Stacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">栈运行原理？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">栈帧的内部结构？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Native-Method-Stacks-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">Native Method Stacks 本地方法栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-Heap"><span class="toc-number">1.1.4.</span> <span class="toc-text">堆(Heap)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%A6%82%E8%BF%B0%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">堆的概述注意点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#JDK7%E5%92%8CJDK8%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">JDK7和JDK8的变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">设置堆空间的内存大小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">堆空间中的年轻代与老年代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%B9%B4%E9%BE%84%E6%AE%B5%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">针对不同年龄段的对象分配原则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">常用调优工具</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DGC%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">三种GC区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#STW"><span class="toc-number">1.1.4.9.</span> <span class="toc-text">STW</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%88%86%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.1.4.10.</span> <span class="toc-text">堆为什么进行分代？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TLAB"><span class="toc-number">1.1.4.11.</span> <span class="toc-text">TLAB</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="toc-number">1.1.5.</span> <span class="toc-text">方法区(Method Area)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">关于对象的相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">对象实例化步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringTable-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text">StringTable 字符串常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88Execution-engine%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">解释器 执行引擎（Execution engine）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.</span> <span class="toc-text">GC垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">垃圾标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">标记-清除算法（Mark - Sweep）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%88Copying%EF%BC%89"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">复制算法（Copying）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">标记-压缩算法（Mark - Compact）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#System-gc%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">System.gc的理解？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">内存溢出与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">内存泄漏案例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">内存溢出解决方案</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Stop-The-World"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">Stop The World</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89%E4%B8%8E%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">程序的并发（Concurrent）与并行（Parallel）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number"></span> <span class="toc-text">安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%85%88%E5%BC%8F%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%BB%E5%8A%A8%E5%BC%8F%E4%B8%AD%E6%96%AD"><span class="toc-number">0.1.</span> <span class="toc-text">抢先式中断和主动式中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">安全区域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-%E4%B8%8D%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">强引用-不回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">软引用-内存不足即回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8-%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">弱引用-发现即回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8-%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA"><span class="toc-number">4.</span> <span class="toc-text">虚引用-对象回收跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">终结器引用</span></a></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        





      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="facebook" href="">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" href="">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="wechat" href="">
            <i class="iconfont icon-wechat"></i>
          </a>
        </li>
      
        <li>
          <a title="weibo" href="">
            <i class="iconfont icon-weibo"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © Oranges 2023</a>
        
    </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + JVM + '&url=' + http%3A%2F%2Fexample.com%2F2023%2F09%2F10%2FJVM%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2023/09/10/JVM/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
